<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.9.9" created="2018-12-21 13:58" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>邓承超的个人博客</title>
	<link>http://dengchengchao.com</link>
	<description>dengchengchao.com</description>
	<pubDate>Fri, 21 Dec 2018 13:58:00 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://dengchengchao.com</wp:base_site_url>
	<wp:base_blog_url>http://dengchengchao.com</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[dengchengchao@outlook.com]]></wp:author_login><wp:author_email><![CDATA[dengchengchao@outlook.com]]></wp:author_email><wp:author_display_name><![CDATA[dengchengchao@outlook.com]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

	<wp:category>
		<wp:term_id>3</wp:term_id>
		<wp:category_nicename><![CDATA[code]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[技术日志]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>1</wp:term_id>
		<wp:category_nicename><![CDATA[uncategorized]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[未分类]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>4</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[杂记]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>5</wp:term_id>
		<wp:category_nicename><![CDATA[%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:category_parent>
		<wp:cat_name><![CDATA[正则表达式]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>52</wp:term_id>
		<wp:category_nicename><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[设计模式]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>10</wp:term_id>
		<wp:category_nicename><![CDATA[git]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:category_parent>
		<wp:cat_name><![CDATA[git笔记]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>11</wp:term_id>
		<wp:category_nicename><![CDATA[linux]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:category_parent>
		<wp:cat_name><![CDATA[Linux]]></wp:cat_name>
	</wp:category>
	<wp:category>
		<wp:term_id>12</wp:term_id>
		<wp:category_nicename><![CDATA[diary]]></wp:category_nicename>
		<wp:category_parent><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:category_parent>
		<wp:cat_name><![CDATA[日记]]></wp:cat_name>
	</wp:category>
	<wp:tag>
		<wp:term_id>13</wp:term_id>
		<wp:tag_slug><![CDATA[%e3%80%8aeffective-java%e3%80%8b]]></wp:tag_slug>
		<wp:tag_name><![CDATA[《Effective Java》]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>14</wp:term_id>
		<wp:tag_slug><![CDATA[%e3%80%8amaven%e5%ae%9e%e6%88%98%e3%80%8b]]></wp:tag_slug>
		<wp:tag_name><![CDATA[《Maven实战》]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>15</wp:term_id>
		<wp:tag_slug><![CDATA[%e3%80%8athinking-in-java%e3%80%8b]]></wp:tag_slug>
		<wp:tag_name><![CDATA[《Thinking in Java》]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>16</wp:term_id>
		<wp:tag_slug><![CDATA[arraylist]]></wp:tag_slug>
		<wp:tag_name><![CDATA[ArrayList]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>17</wp:term_id>
		<wp:tag_slug><![CDATA[c-primer]]></wp:tag_slug>
		<wp:tag_name><![CDATA[C++ primer]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>18</wp:term_id>
		<wp:tag_slug><![CDATA[ad]]></wp:tag_slug>
		<wp:tag_name><![CDATA[ces]]></wp:tag_name>
<wp:tag_description><![CDATA[asd]]></wp:tag_description>
	</wp:tag>
	<wp:tag>
		<wp:term_id>43</wp:term_id>
		<wp:tag_slug><![CDATA[file]]></wp:tag_slug>
		<wp:tag_name><![CDATA[File]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>45</wp:term_id>
		<wp:tag_slug><![CDATA[files]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Files]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>19</wp:term_id>
		<wp:tag_slug><![CDATA[foreach]]></wp:tag_slug>
		<wp:tag_name><![CDATA[foreach]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>20</wp:term_id>
		<wp:tag_slug><![CDATA[git%e7%ac%94%e8%ae%b0]]></wp:tag_slug>
		<wp:tag_name><![CDATA[git笔记]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>21</wp:term_id>
		<wp:tag_slug><![CDATA[hashmap]]></wp:tag_slug>
		<wp:tag_name><![CDATA[HashMap]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>51</wp:term_id>
		<wp:tag_slug><![CDATA[idea]]></wp:tag_slug>
		<wp:tag_name><![CDATA[IDEA]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>37</wp:term_id>
		<wp:tag_slug><![CDATA[java]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Java]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>22</wp:term_id>
		<wp:tag_slug><![CDATA[java-%e5%9f%ba%e7%a1%80]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Java 基础]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>23</wp:term_id>
		<wp:tag_slug><![CDATA[java-%e5%b9%b2%e8%b4%a7]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Java 干货]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>47</wp:term_id>
		<wp:tag_slug><![CDATA[java-%e8%af%ad%e6%b3%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Java 语法]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>56</wp:term_id>
		<wp:tag_slug><![CDATA[javaagent]]></wp:tag_slug>
		<wp:tag_name><![CDATA[JavaAgent]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>50</wp:term_id>
		<wp:tag_slug><![CDATA[java%e5%b7%a5%e5%85%b7]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Java工具]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>49</wp:term_id>
		<wp:tag_slug><![CDATA[jmh]]></wp:tag_slug>
		<wp:tag_name><![CDATA[JMH]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>54</wp:term_id>
		<wp:tag_slug><![CDATA[jvm]]></wp:tag_slug>
		<wp:tag_name><![CDATA[JVM]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>24</wp:term_id>
		<wp:tag_slug><![CDATA[linkedlist]]></wp:tag_slug>
		<wp:tag_name><![CDATA[LinkedList]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>25</wp:term_id>
		<wp:tag_slug><![CDATA[linux]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Linux]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>44</wp:term_id>
		<wp:tag_slug><![CDATA[path]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Path]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>46</wp:term_id>
		<wp:tag_slug><![CDATA[switch]]></wp:tag_slug>
		<wp:tag_name><![CDATA[switch]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>41</wp:term_id>
		<wp:tag_slug><![CDATA[utf8-%e7%bc%96%e7%a0%81]]></wp:tag_slug>
		<wp:tag_name><![CDATA[UTF8 编码]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>26</wp:term_id>
		<wp:tag_slug><![CDATA[webrtc]]></wp:tag_slug>
		<wp:tag_name><![CDATA[webRTC]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>27</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[代码优化]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>38</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%86%85%e9%83%a8%e7%b1%bb]]></wp:tag_slug>
		<wp:tag_name><![CDATA[内部类]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>39</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b9%b2%e8%b4%a7]]></wp:tag_slug>
		<wp:tag_name><![CDATA[干货]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>28</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%bc%82%e5%b8%b8%e8%ae%b0%e5%bd%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[异常记录]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>36</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8a%80%e6%9c%af%e5%b9%b2%e8%b4%a7]]></wp:tag_slug>
		<wp:tag_name><![CDATA[技术干货]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>29</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8a%80%e6%9c%af%e7%b2%be%e9%80%89]]></wp:tag_slug>
		<wp:tag_name><![CDATA[技术精选]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>40</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%b3%9b%e5%9e%8b]]></wp:tag_slug>
		<wp:tag_name><![CDATA[泛型]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>30</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%b5%ae%e7%82%b9%e6%95%b0]]></wp:tag_slug>
		<wp:tag_name><![CDATA[浮点数]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>31</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%b1%bb%e5%88%9d%e5%a7%8b%e5%8c%96]]></wp:tag_slug>
		<wp:tag_name><![CDATA[类初始化]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>55</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%b1%bb%e5%8a%a0%e8%bd%bd]]></wp:tag_slug>
		<wp:tag_name><![CDATA[类加载]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>48</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%bc%96%e7%a0%81]]></wp:tag_slug>
		<wp:tag_name><![CDATA[编码]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>32</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%bd%91%e7%bb%9c]]></wp:tag_slug>
		<wp:tag_name><![CDATA[网络]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>53</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[设计模式]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>58</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%8c%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82%ef%bc%8c%e5%88%9b%e5%bb%ba%e5%9e%8b%e6%a8%a1%e5%bc%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[设计模式，简单工厂，创建型模式]]></wp:tag_name>
	</wp:tag>
	<wp:tag>
		<wp:term_id>57</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99]]></wp:tag_slug>
		<wp:tag_name><![CDATA[面向对象设计原则]]></wp:tag_name>
	</wp:tag>
	<wp:term>
		<wp:term_id><![CDATA[13]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e3%80%8aeffective-java%e3%80%8b]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[《Effective Java》]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[14]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e3%80%8amaven%e5%ae%9e%e6%88%98%e3%80%8b]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[《Maven实战》]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[15]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e3%80%8athinking-in-java%e3%80%8b]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[《Thinking in Java》]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[16]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[arraylist]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[ArrayList]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[17]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[c-primer]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[C++ primer]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[18]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ad]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[ces]]></wp:term_name>
		<wp:term_description><![CDATA[asd]]></wp:term_description>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[43]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[file]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[File]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[45]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[files]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Files]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[19]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[foreach]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[foreach]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[20]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[git%e7%ac%94%e8%ae%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[git笔记]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[21]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[hashmap]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[HashMap]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[51]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[idea]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[IDEA]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[37]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[java]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Java]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[22]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[java-%e5%9f%ba%e7%a1%80]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Java 基础]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[23]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[java-%e5%b9%b2%e8%b4%a7]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Java 干货]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[47]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[java-%e8%af%ad%e6%b3%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Java 语法]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[56]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[javaagent]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[JavaAgent]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[50]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[java%e5%b7%a5%e5%85%b7]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Java工具]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[49]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[jmh]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[JMH]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[54]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[jvm]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[JVM]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[24]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linkedlist]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[LinkedList]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[25]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linux]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Linux]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[44]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[path]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Path]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[33]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_format]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[post-format-aside]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[post-format-aside]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[34]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_format]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[post-format-link]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[post-format-link]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[46]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[switch]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[switch]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[41]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[utf8-%e7%bc%96%e7%a0%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[UTF8 编码]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[26]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[webrtc]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[webRTC]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[27]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[代码优化]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[38]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%86%85%e9%83%a8%e7%b1%bb]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[内部类]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[39]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b2%e8%b4%a7]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[干货]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[28]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%bc%82%e5%b8%b8%e8%ae%b0%e5%bd%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[异常记录]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[36]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8a%80%e6%9c%af%e5%b9%b2%e8%b4%a7]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[技术干货]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[3]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[code]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[技术日志]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[29]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8a%80%e6%9c%af%e7%b2%be%e9%80%89]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[技术精选]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[1]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uncategorized]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[未分类]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[4]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[杂记]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[5]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:term_parent>
		<wp:term_name><![CDATA[正则表达式]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[40]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%b3%9b%e5%9e%8b]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[泛型]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[30]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%b5%ae%e7%82%b9%e6%95%b0]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[浮点数]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[31]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%b1%bb%e5%88%9d%e5%a7%8b%e5%8c%96]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[类初始化]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[55]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%b1%bb%e5%8a%a0%e8%bd%bd]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[类加载]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[48]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bc%96%e7%a0%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[编码]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[32]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bd%91%e7%bb%9c]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[网络]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[52]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[设计模式]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[53]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[设计模式]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[59]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[nav_menu]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[设计模式]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[58]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%8c%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82%ef%bc%8c%e5%88%9b%e5%bb%ba%e5%9e%8b%e6%a8%a1%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[设计模式，简单工厂，创建型模式]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[42]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[nav_menu]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%af%bb%e8%bf%87%e7%9a%84%e4%b9%a6]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[读过的书]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[57]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[面向对象设计原则]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[10]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[git]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:term_parent>
		<wp:term_name><![CDATA[git笔记]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[11]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linux]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:term_parent>
		<wp:term_name><![CDATA[Linux]]></wp:term_name>
	</wp:term>
	<wp:term>
		<wp:term_id><![CDATA[12]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[diary]]></wp:term_slug>
		<wp:term_parent><![CDATA[%e6%9d%82%e8%ae%b0]]></wp:term_parent>
		<wp:term_name><![CDATA[日记]]></wp:term_name>
	</wp:term>
	<wp:term><wp:term_id>59</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:term_slug><wp:term_name><![CDATA[设计模式]]></wp:term_name>
</wp:term>
	<wp:term><wp:term_id>42</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug><![CDATA[%e8%af%bb%e8%bf%87%e7%9a%84%e4%b9%a6]]></wp:term_slug><wp:term_name><![CDATA[读过的书]]></wp:term_name>
</wp:term>

	<generator>https://wordpress.org/?v=4.9.9</generator>

<image>
	<url>http://dengchengchao.com/wp-content/uploads/2018/11/cropped-1-32x32.png</url>
	<title>邓承超的个人博客</title>
	<link>http://dengchengchao.com</link>
	<width>32</width>
	<height>32</height>
</image> 

	<item>
		<title>反射 (1)</title>
		<link>http://dengchengchao.com/?attachment_id=483</link>
		<pubDate>Mon, 05 Nov 2018 08:56:32 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/11/反射-1.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>483</wp:post_id>
		<wp:post_date><![CDATA[2018-11-05 16:56:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-05 08:56:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%8f%8d%e5%b0%84-1]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/11/反射-1.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/11/反射-1.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:200;s:6:"height";i:200;s:4:"file";s:20:"2018/11/反射-1.png";s:5:"sizes";a:1:{s:9:"thumbnail";a:4:{s:4:"file";s:20:"反射-1-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>cropped-1.png</title>
		<link>http://dengchengchao.com/?attachment_id=484</link>
		<pubDate>Mon, 05 Nov 2018 08:56:47 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/11/反射cropped-1.png</guid>
		<description></description>
		<content:encoded><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/11/反射cropped-1.png]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>484</wp:post_id>
		<wp:post_date><![CDATA[2018-11-05 16:56:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-05 08:56:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[cropped-1-png]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/11/cropped-1.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/11/cropped-1.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_context]]></wp:meta_key>
			<wp:meta_value><![CDATA[site-icon]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:512;s:6:"height";i:512;s:4:"file";s:21:"2018/11/cropped-1.png";s:5:"sizes";a:6:{s:9:"thumbnail";a:4:{s:4:"file";s:21:"cropped-1-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:21:"cropped-1-300x300.png";s:5:"width";i:300;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-270";a:4:{s:4:"file";s:21:"cropped-1-270x270.png";s:5:"width";i:270;s:6:"height";i:270;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-192";a:4:{s:4:"file";s:21:"cropped-1-192x192.png";s:5:"width";i:192;s:6:"height";i:192;s:9:"mime-type";s:9:"image/png";}s:13:"site_icon-180";a:4:{s:4:"file";s:21:"cropped-1-180x180.png";s:5:"width";i:180;s:6:"height";i:180;s:9:"mime-type";s:9:"image/png";}s:12:"site_icon-32";a:4:{s:4:"file";s:19:"cropped-1-32x32.png";s:5:"width";i:32;s:6:"height";i:32;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>我看过的书</title>
		<link>http://dengchengchao.com/?page_id=806</link>
		<pubDate>Mon, 12 Nov 2018 10:25:24 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?page_id=806</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>806</wp:post_id>
		<wp:post_date><![CDATA[2018-11-12 18:25:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-12 10:25:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[books]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[page-template-books.php]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>test</title>
		<link>http://dengchengchao.com/?page_id=819</link>
		<pubDate>Mon, 12 Nov 2018 11:00:31 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?page_id=819</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>819</wp:post_id>
		<wp:post_date><![CDATA[2018-11-12 19:00:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-12 11:00:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[test]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[page-template-books.php]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>maven</title>
		<link>http://dengchengchao.com/?attachment_id=845</link>
		<pubDate>Thu, 15 Nov 2018 13:00:24 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/11/maven.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>845</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 21:00:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 13:00:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[maven]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/11/maven.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/11/maven.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:273;s:6:"height";i:358;s:4:"file";s:17:"2018/11/maven.png";s:5:"sizes";a:2:{s:9:"thumbnail";a:4:{s:4:"file";s:17:"maven-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:17:"maven-229x300.png";s:5:"width";i:229;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ThinginJava</title>
		<link>http://dengchengchao.com/?attachment_id=846</link>
		<pubDate>Thu, 15 Nov 2018 13:02:17 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/11/ThinginJava.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>846</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 21:02:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 13:02:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[thinginjava]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/11/ThinginJava.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/11/ThinginJava.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:190;s:6:"height";i:265;s:4:"file";s:23:"2018/11/ThinginJava.png";s:5:"sizes";a:1:{s:9:"thumbnail";a:4:{s:4:"file";s:23:"ThinginJava-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Effective Java</title>
		<link>http://dengchengchao.com/?attachment_id=847</link>
		<pubDate>Thu, 15 Nov 2018 13:07:48 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/11/Effective-Java.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>847</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 21:07:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 13:07:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[effective-java]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/11/Effective-Java.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/11/Effective-Java.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:260;s:6:"height";i:326;s:4:"file";s:26:"2018/11/Effective-Java.png";s:5:"sizes";a:2:{s:9:"thumbnail";a:4:{s:4:"file";s:26:"Effective-Java-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:26:"Effective-Java-239x300.png";s:5:"width";i:239;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>JVM</title>
		<link>http://dengchengchao.com/?attachment_id=848</link>
		<pubDate>Thu, 15 Nov 2018 13:11:42 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/11/JVM.jpg</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>848</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 21:11:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 13:11:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[jvm]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/11/JVM.jpg]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/11/JVM.jpg]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:375;s:6:"height";i:500;s:4:"file";s:15:"2018/11/JVM.jpg";s:5:"sizes";a:2:{s:9:"thumbnail";a:4:{s:4:"file";s:15:"JVM-150x150.jpg";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:10:"image/jpeg";}s:6:"medium";a:4:{s:4:"file";s:15:"JVM-225x300.jpg";s:5:"width";i:225;s:6:"height";i:300;s:9:"mime-type";s:10:"image/jpeg";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Primer</title>
		<link>http://dengchengchao.com/?attachment_id=849</link>
		<pubDate>Thu, 15 Nov 2018 13:18:21 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/11/Primer.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>849</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 21:18:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 13:18:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[primer]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/11/Primer.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/11/Primer.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:380;s:6:"height";i:499;s:4:"file";s:18:"2018/11/Primer.png";s:5:"sizes";a:2:{s:9:"thumbnail";a:4:{s:4:"file";s:18:"Primer-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:18:"Primer-228x300.png";s:5:"width";i:228;s:6:"height";i:300;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>读过的书</title>
		<link>http://dengchengchao.com/?p=853</link>
		<pubDate>Thu, 15 Nov 2018 13:34:51 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/2018/11/15/%e8%af%bb%e8%bf%87%e7%9a%84%e4%b9%a6/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>853</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 21:34:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 13:34:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%af%bb%e8%bf%87%e7%9a%84%e4%b9%a6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="%e8%af%bb%e8%bf%87%e7%9a%84%e4%b9%a6"><![CDATA[读过的书]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[853]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://dengchengchao.com/?page_id=806]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>首页</title>
		<link>http://dengchengchao.com/?p=855</link>
		<pubDate>Thu, 15 Nov 2018 13:35:25 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/2018/11/15/%e9%a6%96%e9%a1%b5/</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>855</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 21:35:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 13:35:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%a6%96%e9%a1%b5]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="%e8%af%bb%e8%bf%87%e7%9a%84%e4%b9%a6"><![CDATA[读过的书]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[855]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://dengchengchao.com]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>关于我</title>
		<link>http://dengchengchao.com/?page_id=856</link>
		<pubDate>Fri, 16 Nov 2018 01:42:06 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?page_id=856</guid>
		<description></description>
		<content:encoded><![CDATA[####
我就是我，不一样的花火~

github:  <a href="https://github.com/dengchengchao" title="https://github.com/dengchengchao">https://github.com/dengchengchao</a>
email ： dengchengchao@outlook.com
####]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>856</wp:post_id>
		<wp:post_date><![CDATA[2018-11-16 09:42:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-16 01:42:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e6%88%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://dengchengchao.com/?p=859</link>
		<pubDate>Fri, 16 Nov 2018 01:42:41 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/2018/11/16/859/</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>859</wp:post_id>
		<wp:post_date><![CDATA[2018-11-16 09:42:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-16 01:42:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[859]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="%e8%af%bb%e8%bf%87%e7%9a%84%e4%b9%a6"><![CDATA[读过的书]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[856]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Pure-Pure-1.0.0</title>
		<link>http://dengchengchao.com/?p=908</link>
		<pubDate>Thu, 29 Nov 2018 06:21:40 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/2018/11/29/pure-pure-1-0-0/</guid>
		<description></description>
		<content:encoded><![CDATA[.th{
	text-align:center
}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>908</wp:post_id>
		<wp:post_date><![CDATA[2018-11-29 14:21:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-29 06:21:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[pure-pure-1-0-0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[custom_css]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
	</item>
	<item>
		<title>classLoad</title>
		<link>http://dengchengchao.com/?attachment_id=928</link>
		<pubDate>Mon, 10 Dec 2018 12:34:28 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/12/classLoad.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>928</wp:post_id>
		<wp:post_date><![CDATA[2018-12-10 20:34:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-10 12:34:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[classload]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/12/classLoad.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/12/classLoad.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:1392;s:6:"height";i:898;s:4:"file";s:21:"2018/12/classLoad.png";s:5:"sizes";a:5:{s:9:"thumbnail";a:4:{s:4:"file";s:21:"classLoad-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:21:"classLoad-300x194.png";s:5:"width";i:300;s:6:"height";i:194;s:9:"mime-type";s:9:"image/png";}s:12:"medium_large";a:4:{s:4:"file";s:21:"classLoad-768x495.png";s:5:"width";i:768;s:6:"height";i:495;s:9:"mime-type";s:9:"image/png";}s:5:"large";a:4:{s:4:"file";s:22:"classLoad-1024x661.png";s:5:"width";i:1024;s:6:"height";i:661;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:21:"classLoad-825x510.png";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>coding</title>
		<link>http://dengchengchao.com/?attachment_id=943</link>
		<pubDate>Fri, 14 Dec 2018 07:41:59 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/12/coding-1.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>943</wp:post_id>
		<wp:post_date><![CDATA[2018-12-14 15:41:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-14 07:41:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[coding-2]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/12/coding-1.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/12/coding-1.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:945;s:6:"height";i:530;s:4:"file";s:20:"2018/12/coding-1.png";s:5:"sizes";a:4:{s:9:"thumbnail";a:4:{s:4:"file";s:20:"coding-1-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:20:"coding-1-300x168.png";s:5:"width";i:300;s:6:"height";i:168;s:9:"mime-type";s:9:"image/png";}s:12:"medium_large";a:4:{s:4:"file";s:20:"coding-1-768x431.png";s:5:"width";i:768;s:6:"height";i:431;s:9:"mime-type";s:9:"image/png";}s:14:"post-thumbnail";a:4:{s:4:"file";s:20:"coding-1-825x510.png";s:5:"width";i:825;s:6:"height";i:510;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>simpleFactory</title>
		<link>http://dengchengchao.com/?attachment_id=958</link>
		<pubDate>Fri, 21 Dec 2018 12:53:29 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/wp-content/uploads/2018/12/simpleFactory.png</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>958</wp:post_id>
		<wp:post_date><![CDATA[2018-12-21 20:53:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-21 12:53:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[simplefactory]]></wp:post_name>
		<wp:status><![CDATA[inherit]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[attachment]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:attachment_url><![CDATA[http://dengchengchao.com/wp-content/uploads/2018/12/simpleFactory.png]]></wp:attachment_url>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attached_file]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018/12/simpleFactory.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_attachment_metadata]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:5:{s:5:"width";i:823;s:6:"height";i:367;s:4:"file";s:25:"2018/12/simpleFactory.png";s:5:"sizes";a:3:{s:9:"thumbnail";a:4:{s:4:"file";s:25:"simpleFactory-150x150.png";s:5:"width";i:150;s:6:"height";i:150;s:9:"mime-type";s:9:"image/png";}s:6:"medium";a:4:{s:4:"file";s:25:"simpleFactory-300x134.png";s:5:"width";i:300;s:6:"height";i:134;s:9:"mime-type";s:9:"image/png";}s:12:"medium_large";a:4:{s:4:"file";s:25:"simpleFactory-768x342.png";s:5:"width";i:768;s:6:"height";i:342;s:9:"mime-type";s:9:"image/png";}}s:10:"image_meta";a:12:{s:8:"aperture";s:1:"0";s:6:"credit";s:0:"";s:6:"camera";s:0:"";s:7:"caption";s:0:"";s:17:"created_timestamp";s:1:"0";s:9:"copyright";s:0:"";s:12:"focal_length";s:1:"0";s:3:"iso";s:1:"0";s:13:"shutter_speed";s:1:"0";s:5:"title";s:0:"";s:11:"orientation";s:1:"0";s:8:"keywords";a:0:{}}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>设计模式</title>
		<link>http://dengchengchao.com/?page_id=962</link>
		<pubDate>Fri, 21 Dec 2018 13:10:47 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?page_id=962</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>962</wp:post_id>
		<wp:post_date><![CDATA[2018-12-21 21:10:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-21 13:10:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_customize_changeset_uuid]]></wp:meta_key>
			<wp:meta_value><![CDATA[49910651-d3c2-47e2-bfbd-35e37438e8b1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>设计模式</title>
		<link>http://dengchengchao.com/?p=964</link>
		<pubDate>Fri, 21 Dec 2018 13:10:47 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=964</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>964</wp:post_id>
		<wp:post_date><![CDATA[2018-12-21 21:10:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-21 13:10:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[964]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://dengchengchao.com/?cat=52]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>设计模式</title>
		<link>http://dengchengchao.com/?p=966</link>
		<pubDate>Fri, 21 Dec 2018 13:11:42 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=966</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>966</wp:post_id>
		<wp:post_date><![CDATA[2018-12-21 21:11:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-21 13:11:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="%e8%af%bb%e8%bf%87%e7%9a%84%e4%b9%a6"><![CDATA[读过的书]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[966]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://dengchengchao.com/?cat=52]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 编码那些事（一）</title>
		<link>http://dengchengchao.com/?p=793</link>
		<pubDate>Thu, 08 Nov 2018 07:06:29 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=793</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>编码</h3>

做Web的同学，最开始一定遇到过乱码问题，工作这么久，一定听说过<code>Unicode</code>,<code>GB2312</code>等编码。典型的记事本选择的四种选项：<code>ANSI,Unicode,Unicode big endian,UTF-8</code>，有没有疑惑，这都是些什么鬼？？？

<h3>什么是编码？</h3>

众所周知，计算机存储都是0和1，那计算机是如何区分开汉字，字母呢？后来人们就规定了一个编码表，这个表就相当于一个<strong>字典</strong>,比如我们通俗约定1100001就表示<code>A</code>,1100002表示<code>B</code>做计算机显示的时候，发现一个字符对象存储的值是<code>1100001</code>那就显示<code>A</code>就行了。像这样，<em>由信息的一种形式转换为另外一种形式的过程，称为编码。</em>而编码表便是编码过程的一种规则。

<h3>ASCII</h3>

<code>ASCII(American Standard Code for Information Interchange)</code>是最出名也是最基本的编码表，最开始计算机发明的时候，计算机的使用一般都是一些特殊字符加上26个字母，因此美国人定制了ASCII表用来显示通用的26个字符加上一些特殊字母，ASCII码只占用一个1字节。

<h3>ANSI</h3>

最开始ASCII编码是够用的，但是随着计算机的发展，越来越多的国家陆续用上了计算机，这个时候，母语非英语的国家就开始不满意了，ASCII只能表示26个英文字母，那法语（é），汉语（中国），德语（Ä ä）等也要在计算机中表示，于是最开始，每个国家都自己定义了一套关于自己的编码规则，其中比较出名的有：

<ul>
<li>西欧 ISO 8859-1</li>
<li>中国国标  GB 2312</p></li>
<li><p>台湾同胞的繁体 Big 5</p></li>
<li><p>日本 Shift_ JIS</p></li>
</ul>

<p>这些都是编码都是在原有的ASCII基础上扩展而来，统称为<code>ANSI</code>编码。但是最大的缺点就是<strong>互不兼容</strong>，也就是每个编码都是在没有考虑其他国家的定义的基础上扩展的。一边来说，在解码/编码过程中，都是指定具体的编码，比如GBK2312，ISO  8859-1 等，<strong>ANSI</strong>只是对上述编码的一种统称。使用<strong>ANSI</strong>来作为一种编码格式的一般只见于Windows自带的记事本中。而在Windows记事本中，不同语言的操作系统，记事本所指的<strong>ANSI</strong>是不同的，

<ul>
<li>简体中文 GBK</li>
<li>日文 Shift_JIS</li>
<li>繁体中文 Big 5</li>
<li>...</li>
</ul>

因此，对于Windows的记事本，<strong>ANSI</strong>需要看具体的编码。

<h3>UNICODE</h3>

首先需要明确的是<code>UNICODE</code>是将<strong>字符集</strong>和<strong>编码方式</strong>分开的一种方案，在<a href="https://zh.wikipedia.org/wiki/Unicode">维基百科</a>中又被称做万国码、国际码。由名字便可知道，<code>Unicode</code>统一了各个国家的字符并规定了每个符号的编码，在<code>Unicode</code><strong>字符集</strong>中，每个字符占用两个字节表示。<code>ANSI</code>类的字符集合编码都是一对一的关系，一种字符集对应一种编码。在<code>Unicode</code>编码中，Unicode编码的实现方式被称为<strong>Unicode转换格式</strong>（<code>Unicode Transformation Format</code>，简称为<code>UTF</code>）：代表性的有以下几种：

<ul>
<li>UTF-8： 前面说得到，<code>Unicode</code>字符集是以2个字节表示一个字符，但是在有时候只需要<code>ASCII</code>编码即可完整表示所有内容的系统中，使用<code>Unicode</code>会浪费比较多的控件，因此出现了<code>UTF-8</code>编码，<code>UTF-8</code>ayi 是一种变长编码。UTF-8在编码<code>Unicode</code>码的时候，会将小位数的字符进行压缩，因此使用<code>UTF-8</code>的表示一个字母的时候，依然只使用一个字节。<code>UTF-8</code>对常用的字符一般3个字节即可表示，最多6个字节。（尽管如此，2003年11月<code>UTF-8</code>被RFC 3629重新规范，只能使用原来<code>Unicode</code>定义的区域，U+0000到U+10FFFF，也就是说最多四个字节：<a href="https://zh.wikipedia.org/wiki/UTF-8">维基百科</a>）</li>
<li>UTF-16:  <code>UTF-16</code>使用16位作为一个字长单位，使用<code>UTF-16</code>要么是两个字节表示一个字符，要么是4个字节。不过值得注意的是不同的操作系统读取直接的顺序不同，就好像古人写字是从右往左写一样，这里顺序，称为<strong>字节序</strong>，比如1122，有些系统读出来是1122，而有些系统读出来是2211，所以<code>UTF-16</code>又分大端（<strong>utf16-big endian</strong>）和小端（<strong>utf16-little endian</strong>）表示。</li>
</ul>

<blockquote>
  关于为什么UTF-8 没有字节序的问题，感兴趣的同学可以看看<a href="https://www.zhihu.com/question/55140986/answer/142938758">为什么 UTF-8 不存在字节序的问题？ - 孙笑凡的回答 - 知乎</a>
</blockquote>

说到这里，大概就能分清UNICODE,ANSI,UTF-8,GBK编码了，但是可能有的同学比较疑惑的是Windows自带的笔记本为什么会有个Unicode编码选项？？这算是Windows混用概念问题，在Windows自带笔记本下的Unicode表示的是“Unicode”（对应UTF-16 LE）、“Unicode big endian”（对应UTF-16 BE）

<h3>URLEncoding</h3>

<code>URLEncoding</code>又称为<strong>百分号编码</strong>,其主要作用在于解决在<strong>使用url中混合其他编码的时候所带来的语法冲突</strong>，比如<code>?</code>在URL中，表示参数分割，但是如果想要在参数中传递<code>？</code>就必须通过特殊的转换，而<code>URLEncoding</code>则正是用来将这些特殊符号转换为其他不会有歧义的统一编码。

其主要编码原理在于：将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY格式

部分特殊字符转换规则如下：

<table>
<thead>
<tr>
  <th>空格</th>
  <th>!</th>
  <th>#</th>
  <th>$</th>
  <th>%</th>
  <th>+</th>
  <th>@</th>
  <th>:</th>
  <th>=</th>
  <th>?</th>
</tr>
</thead>
<tbody>
<tr>
  <td>%20</td>
  <td>%21</td>
  <td>%23</td>
  <td>%24</td>
  <td>%25</td>
  <td>%2B</td>
  <td>%40</td>
  <td>%3A</td>
  <td>%3D</td>
  <td>%3F</td>
</tr>
</tbody>
</table>

一般当参数会混合在URL中，都会先将参数进行URL编码再进行传递。比如<strong>Get</strong>请求，或者Http中MIME类型为<code>application/x-www-form-urlencoded</code>的请求

参考文章：

<a href="http://josh-persistence.iteye.com/blog/2233727">编码简介ASCII、Unicode、 GB2312、GBK、GB18030、BIG5、UTF-8、Base64、MBCS</a>

<a href="https://www.zhihu.com/question/20650946/answer/15745831">Windows 记事本的 ANSI、Unicode、UTF-8 这三种编码模式有什么区别？ - 梁海的回答 - 知乎</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>793</wp:post_id>
		<wp:post_date><![CDATA[2018-11-08 15:06:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-08 07:06:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-%e7%bc%96%e7%a0%81%e9%82%a3%e4%ba%9b%e4%ba%8b%ef%bc%88%e4%b8%80%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="post_tag" nicename="utf8-%e7%bc%96%e7%a0%81"><![CDATA[UTF8 编码]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[47]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[%e8%af%b4%e8%af%b4%e7%bc%96%e7%a0%81%ef%bc%8c%e4%bb%a5%e5%90%8e%e5%86%8d%e4%b9%9f%e4%b8%8d%e7%96%91%e6%83%91%e4%ba%86]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>7</wp:comment_id>
			<wp:comment_author><![CDATA[java 编码那些事（二） &#8211; 邓承超的个人博客]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://dengchengchao.com/2018/11/26/java-%e7%bc%96%e7%a0%81%e9%82%a3%e4%ba%9b%e4%ba%8b%ef%bc%88%e4%ba%8c%ef%bc%89/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[94.191.15.206]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-11-26 19:38:08]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-11-26 11:38:08]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 建议首先阅读Java 编码那些事(一) [&#8230;]]]></wp:comment_content>
			<wp:comment_approved><![CDATA[trash]]></wp:comment_approved>
			<wp:comment_type><![CDATA[pingback]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
				<wp:meta_value><![CDATA[1543412611]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>12</wp:comment_id>
			<wp:comment_author><![CDATA[Java 编码那些事（二） &#8211; 邓承超的个人博客]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://dengchengchao.com/?p=887</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[94.191.15.206]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-12-14 15:33:25]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-12-14 07:33:25]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 建议首先阅读Java 编码那些事(一) [&#8230;]]]></wp:comment_content>
			<wp:comment_approved><![CDATA[trash]]></wp:comment_approved>
			<wp:comment_type><![CDATA[pingback]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
				<wp:meta_value><![CDATA[1544773289]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>13</wp:comment_id>
			<wp:comment_author><![CDATA[Java 编码那些事(三) 实战解决IDEA+Tomcat+Servlet 乱码问题 &#8211; 邓承超的个人博客]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://dengchengchao.com/?p=941</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[94.191.15.206]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-12-14 15:39:03]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-12-14 07:39:03]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] Java 编码那些事(一) [&#8230;]]]></wp:comment_content>
			<wp:comment_approved><![CDATA[trash]]></wp:comment_approved>
			<wp:comment_type><![CDATA[pingback]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
				<wp:meta_value><![CDATA[1544773287]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>记一次关于参数过长的代码优化</title>
		<link>http://dengchengchao.com/?p=824</link>
		<pubDate>Thu, 15 Nov 2018 12:48:15 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=824</guid>
		<description></description>
		<content:encoded><![CDATA[背景：<br />
现在有一个<code>POJO</code>作为<code>HTTP Controller</code>参数以及<code>Service</code>参数。
<code>Controller</code>为<code>RESTFul</code>风格
具体如下：

<pre><code class="">@RequestMapping(value = "xxxxx/apps/{app_id}/groups/{group_id}/faces/{face_id}", method = RequestMethod.POST)
    public ResultMsg add(@PathVariable("face_id") String faceId,
                         @PathVariable("app_id") String appId,
                         @PathVariable("group_id") String groupId,
                         @RequestBody FaceRequestBody faceBody
    ) {
        Face face = new Face(faceId,groupId,appId,faceBody.getName(),faceBody.getImage(),faceBody.getRemark(),false);
        return faceService(face);
    }
</code></pre>

可以看到<code>Service</code>层由于特殊原因需要一个<code>POJO</code>：<code>Face</code>,<code>Face</code>包含7个属性，并且每个属性都是必须的。

<pre><code class="">public class Face {

    @JSONField(name = "face_id")
    private String id;

    @JSONField(name = "face_name")
    private String name;


    private String image;

    @JSONField(name = "face_remark")
    private String remark;


    @JSONField(serialize = false)
    private boolean obsolete;

    @JSONField(name = "group_id")
    private String groupId;

    @JSONField(name = "app_id")
    private String appId;

    //setter &amp; getter
}
</code></pre>

<code>Face</code> 的构造器参数有7个，基本每个都是<code>String</code>类型，这样及其不方便并且容易出错，想着用建造者模式优化。

<hr />

思路：可以看见，由于没有可选参数，于是传统的建造者模式是不适用于现在的场景，但是我们可以借鉴建造者模式的返回<code>this</code>的“连点”技巧。

<ol>
<li>分析7个参数，从应用场景来说，7个参数可以分为3类，````id<code>类，</code>info<code>类，</code>obsolete```类，因此我们可以创建3个嵌套类。</li>
<li>如果直接暴力拆分为3个类，代码依然不美观，每次新建一个<code>Face</code>类都要new其他3个类。

<pre><code class="">Infos infos=new Infos(...);
Ids id=new Ids(...);
Obsolete obsolete=new Obsolete(...);
Face face = new Face(infos,id,obsolete);

</code></pre></li>
<li>正如最开始所说，借鉴建造者模式的“连点”语法技巧。</li>
</ol>

<pre><code class="">    /**
     * Face 构造器
     * 由于Face参数过多,并且每个参数都是必须参数。
     * 此嵌套类可以将相关属性分开构造，防止因为参数过多传错参数
     * 使用方法如下：
     * Face face = Face.buildIds(faceId,groupId,appId).
     *                  buildFaceInfo(name,image,remark).
     *                  buildObsolete(false);
     */

    //第一层，返回下一层的新对象
    public static FaceInfoBuilder buildIds(String id, String groupId, String appId) {
        return new FaceInfoBuilder(id, groupId, appId);
    }

    public static final class FaceInfoBuilder {

        private String id;
        private String groupId;
        private String appId;

        private FaceInfoBuilder(String id, String groupId, String appId) {
            this.id = id;
            this.groupId = groupId;
            this.appId = appId;
        }
        //第二层，返回第三层的对象
        public FaceObsoleteBuilder buildFaceInfo(String name, String image, String remark) {
            return new FaceObsoleteBuilder(id, groupId, appId, name, image, remark);
        }

        public static final class FaceObsoleteBuilder {
            private String id;
            private String groupId;
            private String appId;
            private String image;
            private String name;
            private String remark;

            private FaceObsoleteBuilder(String id, String groupId, String appId, String image, String name, String remark) {
                this.id = id;
                this.groupId = groupId;
                this.appId = appId;
                this.image = image;
                this.name = name;
                this.remark = remark;
            }
            //最后一层，返回Fac对象
            public Face buildObsolete(boolean obsolete) {
                return new Face(id, groupId, appId, name, image, remark, obsolete);
            }
        }

    }
</code></pre>

核心思想：使用3个嵌套类，每一层返回下一层的嵌套类，同时将构造函数设为<code>private</code>类型，防止外部实例化。

优化过后新建一个<code>Face</code>对象如下：

<pre><code class="">Face face = Face.buildIds(faceId,groupId,appId).
                 buildFaceInfo(name,image,remark).
                 buildObsolete(false);
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>824</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:48:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:48:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%ae%b0%e4%b8%80%e6%ac%a1%e5%85%b3%e4%ba%8e%e5%8f%82%e6%95%b0%e8%bf%87%e9%95%bf%e7%9a%84%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>route路由设置记录</title>
		<link>http://dengchengchao.com/?p=826</link>
		<pubDate>Thu, 15 Nov 2018 12:50:35 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=826</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>情景一：</h3>

有一台ip为172.16.160.53服务器，此服务器为固定ip，由于某些特殊情况，此服务器的ip不能修改。<br />
现在这台服务器需要与另外一个网段ip为172.16.176.150服务器进行局域网通信。<br />
局域网通过连接同一个交换机实现。<br />
操作方法：路由表（使用ip route 命令操作静态路由表）<br />
先看看路由表的定义：

<strong>所谓路由表，指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径，在某些情况下，还有一些与这些路径相关的度量。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据——路由表（Routing Table），供路由选择时使用，表中包含的信息决定了数据转发的策略。打个比方，路由表就像我们平时使用的地图一样，标识着各种路线，路由表中保存着子网的标志信息、网上路由器的个数和下一个路由器的名字等内容。路由表根据其建立的方法，可以分为动态路由表和静态路由表。</strong>

解决方法：<br />
172.16.160.35 需要ping 通 172.16.176.150<br />
首先，进入35的服务器中：

<pre><code class="">route -n
</code></pre>

结果如下：

<pre><code class="">内核 IP 路由表
目标            网关            子网掩码        标志  跃点   引用  使用 接口
0.0.0.0         172.16.160.1    0.0.0.0         UG    100    0        0 eno1
172.16.160.0    0.0.0.0         255.255.240.0   U     100    0        0 eno1
</code></pre>

解决方法为：将150的网段路由，添加到35服务器里面就好了。
进入35服务器，查看ip信息

<pre><code class="">ifconfig
</code></pre>

结果如下：

<pre><code class="">xenbr3    Link encap:Ethernet  HWaddr B0:83:FE:D9:B3:2C  
          inet addr:172.16.176.151  Bcast:172.16.191.255  Mask:255.255.240.0
          UP BROADCAST RUNNING  MTU:1500  Metric:1
          RX packets:1533682 errors:0 dropped:139662 overruns:0 frame:0
          TX packets:51720 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:142772383 (136.1 MiB)  TX bytes:23832202 (22.7 MiB)

</code></pre>

可以看到子网掩码：255.255.240.0

<pre><code class="">netstat -r 
</code></pre>

结果如下：

<pre><code class="">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         172.16.176.1    0.0.0.0         UG        0 0          0 xenbr3
172.16.176.0    *               255.255.240.0   U         0 0          0 xenbr3
</code></pre>

可以看到默认网关：172.16.176.1

在35服务器中，输入以下命令：

<pre><code class="">route add -net 172.16.176.0/20 eno1      //20由子网掩码255.255.255.240计算
</code></pre>

或者

<pre><code class="">route add -net  172.16.176.0/20 gw  172.16.176.1 dev eno1
</code></pre>

意思是访问 172.16.176.*网段的数据，都是用172.16.176.1的网关。而默认的使用172.16.160.1的网关。

问题解决

<h3>情景二</h3>

以前服务器在172.16.160网段后，后来因为一定原因，需要把这台服务器换个地方，同时ip也换了，服务器内置了ArteryCloud，直接在界面修改ip后，发现一个奇怪的现象。ping baidu.com 是正常的，但是ping 原本的ip段，却ping不通。

<pre><code class="">route print
</code></pre>

发现

<pre><code class="">default         172.16.176.1    0.0.0.0         UG    0      0        0 xenbr3
172.16.160.0    172.16.160.1    255.255.240.0   U     100    0        0 xenbr0
</code></pre>

意思为160这个网段使用xenbr0网卡，但是xenbr0是不通的。而服务器的网卡只用了一个：xenbr3.
处理方法：

<pre><code class="">route del -net 172.16.160.0 dev xenbr0
</code></pre>

都是用默认的路由就ok]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>826</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:50:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:50:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[route%e8%b7%af%e7%94%b1%e8%ae%be%e7%bd%ae%e8%ae%b0%e5%bd%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>LinkedList源码小记</title>
		<link>http://dengchengchao.com/?p=828</link>
		<pubDate>Thu, 15 Nov 2018 12:50:48 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=828</guid>
		<description></description>
		<content:encoded><![CDATA[<ol>
<li><code>LinkedList#clear()</code>方法并不是简单的将<code>last</code>和<code>first</code>节点置为<code>null</code>，而是遍历所有节点，分别将每个节点置为<code>null</code>也就说<code>LinkedList#clear()</code>时间复杂度不是O(1)而是O(n)

<pre><code class="language-java ">   public void clear() {
       // Clearing all of the links between nodes is "unnecessary", but:
       // - helps a generational GC if the discarded nodes inhabit
       //   more than one generation
       // - is sure to free memory even if there is a reachable Iterator
       for (Node&lt;E&gt; x = first; x != null; ) {
           Node&lt;E&gt; next = x.next;
           x.item = null;
           x.next = null;
           x.prev = null;
           x = next;
       }
       first = last = null;
       size = 0;
       modCount++;
   }
</code></pre>

可以看到相关解释：

<ol>
<li>在分代GC中，通常<code>List</code>本身和较旧的节点一般处于比其他节点更老的一代，这样就好导致在发现所有节点都是垃圾之前，年轻的节点并没有被回收而且已经被复制了好几次，这几次复制都是无用功。</li>
<li>在调用这个方法后，即使迭代器还持有它们的引用，这些节点也会被回收。</li>
</ol></li>
<li><code>LinkedList</code>实现了<code>Deque</code>接口，<code>Deque</code>中，包含了容器，栈，队列。因此在需要栈，队列的时候，可以使用<code>Deque</code>接口</p></li>
</ol>

<h4>poll,peek</h4>

<p>由于<code>LinkedList</code>实现的特殊性。<code>LinkedList</code>提供了无参<code>remove()</code>方法来默认删除第一个元素。但是有些时候列表中没有任何元素，而对于队列，堆栈等一般都使用循环获取元素，这个时候<code>LinkedList</code>提供了两种方式来判断循环是否到了队尾或队头：

<code>remove()</code>/<code>removeFirst()</code>/<code>removeLast()</code>/<code>element</code>/<code>getFirst()</code>/ <code>getLast()</code> : 当容器为空的时候，抛出异常

<code>poll()</code>/<code>pollFirst()</code>/<code>pollLast()</code>/<code>peek()</code>/<code>peekFirst()</code>/<code>peekLast()</code>: 当容器为空的时候，返回<code>null</code>

<code>add()</code>/<code>addFirst()</code>/<code>addLast()</code> ：当添加失败的时候，抛出异常（某些时候有些容器可能有大小限制）

<code>offer()</code>/<code>offerFirst()</code>/<code>offerLast()</code>:当添加失败的时候，返回<code>false</code>

<h4>更多的区分</h4>

根据JDK的描述，

<code>LinkedList</code>各个方法中：

<code>pop()</code>              //相当于<code>remove()</code>

<code>push()</code>                     //相当于 <code>addFirst()</code>

用于Stack

<hr />

<code>peek()</code>/<code>element()</code>

<code>poll()</code>/<code>remove()</code>

<code>offer()</code>/<code>add()</code>

用于Queue

总结：

<code>remove</code>系列对应<code>poll</code>

<code>get</code>系列对应<code>peek</code>

<code>add</code>系列对应<code>offer</code>

其中:

栈是先进后出，专用对应方法为<code>push(addFirst)</code>,<code>pop（remove）</code>

队列是先进先出，专用对应方法为<code>offer()</code>,<code>poll()</code>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>828</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:50:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:50:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[linkedlist%e6%ba%90%e7%a0%81%e5%b0%8f%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ArrayList源代码小记</title>
		<link>http://dengchengchao.com/?p=830</link>
		<pubDate>Thu, 15 Nov 2018 12:51:01 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=830</guid>
		<description></description>
		<content:encoded><![CDATA[Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)

The <code>size</code>, <code>isEmpty</code>, <code>get</code>, <code>set</code>, <code>iterator</code>, and <code>listIterator</code> operations run in constant time. The <code>add</code> operation runs in <em>amortized constant time</em>, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the <code>LinkedList</code> implementation.

Each <code>ArrayList</code> instance has a <em>capacity</em>. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.

An application can increase the capacity of an <code>ArrayList</code> instance before adding a large number of elements using the <code>ensureCapacity</code> operation. This may reduce the amount of incremental reallocation.

<strong>Note that this implementation is not synchronized.</strong> If multiple threads access an <code>ArrayList</code> instance concurrently, and at least one of the threads modifies the list structurally, it <em>must</em> be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be "wrapped" using the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedList-java.util.List-"><code>Collections.synchronizedList</code></a> method. This is best done at creation time, to prevent accidental unsynchronized access to the list:

<pre><code class="">   List list = Collections.synchronizedList(new ArrayList(...));
</code></pre>

The iterators returned by this class's <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#iterator--"><code>iterator</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#listIterator-int-"><code>listIterator</code></a> methods are <em>fail-fast</em>: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html#remove--"><code>remove</code></a> or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html#add-E-"><code>add</code></a> methods, the iterator will throw a<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ConcurrentModificationException.html"><code>ConcurrentModificationException</code></a>. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.

Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw <code>ConcurrentModificationException</code>on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: <em>the fail-fast behavior of iterators should be used only to detect bugs.</em>

上面是<code>ArrayList</code>的官方文档。

总结一下：

<ol>
<li><code>ArrayList</code>能存储<code>null</code></p></li>
<li><p><code>ArrayList</code>和<code>Vector</code>大致相同，除了<code>ArrayList</code>不是同步的。</p></li>
<li><p><code>get(),set()</code>等操作时间复杂度为O(1)</p></li>
<li>其他操作：<code>add()</code>等时间复杂度都是粗略线性的</li>
<li><code>ArrayList</code>非同步容器，如果需要使用同步<code>ArrayList</code>，可以使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedList-java.util.List-">Collections.synchronizedList`</a>包装这个容器。使用这个包装容器最好在创建是就开始</li>
<li><code>ArrayList</code>所返回的迭代器是快速失败的，在获取迭代器后，应该使用迭代器本身的方法进行<code>remove</code>或<code>add</code></li>
<li>迭代器的快速失败不是绝对保证，因此，编写依赖于此异常的程序以确保其正确性是错误的</li>
</ol>

<h4>Arrays.asList(xx).toArray(xxx) Bug</h4>

<p>相关连接： <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652">Java Bug 6260652</a>

按道理来说，如果没有指定<code>toArray()</code>的参数类型，那么应该返回<code>Object[]</code>类型。但是<code>Arrays.asList(xxx).toArray(xxx)</code>虽然编译时是是返回的<code>Object[]</code>类型，但是运行时还是返回的具体的类型，比如：

<pre><code class="language-java ">        List&lt;String&gt; list = Arrays.asList("1", "2", "3");
        Object[] objects= list.toArray();
        objects[1]=new Object();
</code></pre>

就会报错。

究其原因，是因为<code>Arrays.asList</code>返回的<code>ArrayList</code>是通过泛型数组保存的数据：

<pre><code class="language-java "> private final E[] a;
</code></pre>

而实现<code>toArray()</code>方法的时候，直接返回<code>a.clone</code>,而他的初始化是通过直接等于传入的数组初始化：

<pre><code class="language-java ">    ArrayList(E[] array) {
            a = Objects.requireNonNull(array);
        }

</code></pre>

这样就相当于：

<pre><code class="language-java ">     Object[] a=new String[2];
      a[1]=new Object();
</code></pre>

这样在运行时a的实际类型是<code>String[]</code>，传入一个<code>Object</code>当然不行。

其他容器没有这个bug是因为他们都是通过<code>Object[]</code>保存的元素。

<h4>泛型的类型比较</h4>

在使用泛型的通配符的时候，由于编译期会将通配符替换为：<code>capture#1</code>,这个特殊的类型并不是<code>Object</code>的子类，但是某些时候想想进行类型（class）比较。可以先强制类型转化，然后利用运行时类型进行比较。

<pre><code class="language-java ">   public static &lt;T&gt; void test(Class&lt;? extends T[]&gt; type) {
        System.out.println((Object) type==(Object) Object[].class);
    }
</code></pre>

<blockquote>
  个人感觉还可以使用<code>.isInstance</code>方法
</blockquote>

<pre><code class="language-java "><br />    public static &lt;T&gt; void test(Class&lt;? extends T[]&gt; type) {
        System.out.println(type.isInstance(new Object[0]));
    }
</code></pre>

<h4>数组复制</h4>

数组的拷贝可以使用<code>Arrays.cppyOf(T[],int)</code>

第二个参数为需要生成的数组的长度，可以比原来的大，也可以比原来的小。

如果只是想复制一个一模一样的数组的话，可以使用<code>xx.clone()</code>方法

<code>System.arrayCopy</code>参数比较复杂，<code>Arrays.cppyOf(T[],int)</code>是对它的封装。

<h4>ArrayList</h4>

<code>ArrayList</code>包含两个静态字段

<pre><code class="language-java ">DEFAULTCAPACITY_EMPTY_ELEMENTDATA //用于表示无参初始化，new ArrayList() ，此时内部数组是一个大小为1的数组
EMPTY_ELEMENTDATA //用于表示使用大小为0的容器初始化
</code></pre>

使用<code>EMPTY_ELEMENTDATA</code>标志来表示一个空数组，因为任何空数组都等于空数组，因此可以使用一个静态的空数组来共享表示<code>elementData</code>为空，可以节约内存。

使用<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>标志使用的无参构造函数，便于在第一次<code>add</code>操作的时候，使用<code>DEFAULT_CAPACITY</code>扩容

<h4>terimToSize()</h4>

在确定<code>ArrayList</code>不会插入元素后，可以使用<code>terimToSize()</code>方法将扩容导致多余出来的元素删除。

<h4>toArrays(T[] a)</h4>

由于泛型是通过擦除实现，因此在想要获取指定类型数组而不是<code>Object[]</code>的时候可以使用<code>toArrays(T[] a)</code>方法，此方法有两只使用方式：

<pre><code class="language-java ">String[] array=list.toArray(new String[0]);
//第二种
String[] array1=new String[list.size()];
list.toArray(array1);
</code></pre>

第一种会自己使用<code>Array.newInstance()</code>创建一个合适的大小的数组，第二个是直接拷贝。

《Effective Java》第五十四条说：研究表明使用预先分配大小的方式并不比直接<code>new String[0]</code>快，因此非特殊情况，不必纠结到底使用哪一种。

<h4>有意思的代码</h4>

<pre><code class="language-java ">public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}
</code></pre>

之前一直都说<code>ArrayList</code>底层是通过数组实现，因此在元素中间进行插入和删除操作的时候，需要将所删除的元素的后面的元素一个一个进行移动，性能是比较慢的。

但是可以看到<code>add()</code>方法的实现中，是先扩容，然后使用<code>System.arraycopy</code>直接整段数组复制，这比<code>for</code>循环数组效率要高很多

<pre><code class="language-java ">public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
</code></pre>

同样<code>remove()</code>方法也是，它直接将需要移除的数组整体向前移动一段，覆盖掉要移除的元素。

<h4>subList()</h4>

<code>ArrayList#subList()</code>返回一个包含指定范围的<code>List</code>，但是在<code>ArrayList#subList()</code>返回的是一个内部类：<code>SubList</code>，
说一说这个<code>SubList</code>

<pre><code class="language-java ">final void checkForComodification() {
  if (expectedModCount != ArrayList.this.modCount)
            throw new ConcurrentModificationException();
  }
</code></pre>

这是里面的一个关键方法，对比外部类的<code>modCount</code>与实例化时候初始化的<code>SubList</code>对象的<code>modCount</code>是否相同，不同则抛出异常。

这个方法基本在<code>SubList</code>方法中每个<code>Public</code>方法都会调用。作用是如果外部类修改了元素，则这个<code>SubList</code>便会失效。

为什么这样呢？

看<code>SubList</code>源代码可以发现<code>SubList</code>并没有使用类似<code>ArrayList#Object[]</code>来保存数据成员。而是

<pre><code class="">private final int parentOffset;
private final int offset;
</code></pre>

两个指针。每次对<code>SubList</code>操作其实都是通过这两个指针对外部类数据进行操作。

也就是说<code>SubList</code>和<code>ArrayList</code>是共用同一个<code>elementData</code>的，这样做的好处就是得到一个<code>SubList</code>十分高效，因为并没有进行<code>for</code>循环赋值，而想到得到一个独立的<strong>子ArrayList</strong>,可以如下：

<pre><code class="language-java ">     List&lt;String&gt; subList=new ArrayList&lt;&gt;(arrayList.subList(0,1));
</code></pre>

这样得到的<code>subList</code>便是独立的，并且底层使用的<code>System.arraycopy()</code>，性能比for高效的多。

<h4>Vector</h4>

一般来说，虽然<code>Vector</code>线程安全，但是<code>Vector</code>的实现非常简单，就是在每个操作上添加锁，但是这样的实现既不安全又很慢，不安全是因为我们一般操作都需要给整个容器添加锁，比如遍历整个锁等，而慢是因为对于容器的锁只用在外面一个就能线程全权访问，为什么要每个操作等待一个锁，因此<code>Vector</code>的锁变成了一种负担，在需要使用线程安全的<code>List</code>的时候，

读多：<code>CopyOnWriteArrayList</code>

读写均匀/写多：<code>Collections.synchronizedList</code>

相关连接：[<a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated">Why is Java Vector (and Stack) class considered obsolete or deprecated?</a>]

<h4>总结</h4>

<code>ArrayList</code>算是比较简单的列表容器，底层使用<code>Object</code>数组保存元素，默认扩容大小为10，每次扩容为原来的1.5倍<code>（oldLength + (oldLength&gt;&gt;1)）</code>。里面包含了大量的数组拷贝操作，非线程安全，<code>Arraylist</code>使用全局静态对象标致空对象，重复利用同一个对象，节约内存，<code>ArrayList#remove(Object o)</code>使用了<code>o.equals()</code>方法，因此想要正常工作，元素需要重载<code>equals</code>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>830</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:51:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:51:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[arraylist%e6%ba%90%e4%bb%a3%e7%a0%81%e5%b0%8f%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>2018-10-12 HashMap、浮点数、类初始化等个人思考</title>
		<link>http://dengchengchao.com/?p=832</link>
		<pubDate>Thu, 15 Nov 2018 12:51:51 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=832</guid>
		<description></description>
		<content:encoded><![CDATA[<h4>求一个比给定整数大且最接近的2的幂次方整数</h4>

<blockquote>
  tableSizeFor(3)=4,tableSizeFor(14)=6
</blockquote>

可以使用位运算。

<pre><code class="language-java ">//学习： 与类成员无交互的方法应该定义为static的
static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

</code></pre>

解释：其实很好理解，首先需要知道的一点是

<blockquote>
  2^n-1 的有效比特位全是1<br />
  比如：3 二进制11，7二进制111， 15 二进制 1111  ...
</blockquote>

上面算法也是利用了这一点。直接求出cap-1的有效比特位全是1的数即可。<br />
而右移算法，主要是将最高为1的一直向右复制，因为我们唯一能确定的就是最高位肯定为1.<br />
比如：<br />
10000 右移<strong>一</strong>位：11000，移动后就能确定<strong>最高两位</strong>一定都是1，<br />
再右移<strong>两</strong>位：11110，变成<strong>最高四位</strong>一定都是1，依次类推，一共将32位全部覆盖。<br />
最后再加1得到2的整数次幂。

<h4>Float.isNaN()方法</h4>

有时候传入一个<code>float</code>或者<code>double</code>参数的时候不在运行的时候是无法知道他是不是一个有效的<code>float</code>数值，比如

<pre><code class="language-java "> float a=0;
 float b=0;
 System.out.println(a/b);
</code></pre>

此时不会报错而是输出一个<strong>NaN</strong><br />
这种错误一般不在真正使用这个数字是不会报错的。
而有时候一个程序需要的是一个真正有效数字，因此可以使用

<pre><code class="language-java ">Float.isNaN();
Double.isNaN();
</code></pre>

方法提前进行判断是否为一个真正有效的数字，将错误进行实时定位。

<blockquote>
  isNaN()的源码很简单：      <code>return (v != v);</code><br />
  因为NaN是唯一一个自己不等于自己的数。<br />
  <code>System.out.println(0/0==0/0);//false</code>
</blockquote>

<h4>基本数据类型</h4>

jvm 规范只规定了基本数据类型应该有的有效范围，但是具体在JVM中占多大的内存，并没有规定。<br />
比如 byte只能表示-128-127<br />
但是在JVM中 byte<strong>占用</strong>多大字节是没有规定的，一般JVM都使用int为标准，也就是还是4字节的<br />
在HotSpot VM 中，char在栈上是占用4字节的，在堆上是占用2字节的<br />
相关连接<a href="http://hllvm.group.iteye.com/group/topic/38400">讨论：char在JVM中到底占用几个字节</a>

<h4>浮点数</h4>

浮点数是相对于定点数来说的，浮点数就是小数点浮动的小数。
形似如下：

<pre><code class="language-java ">(+ or -)1.(mantissa)*2^exponent
</code></pre>

<ul>
<li>mantissa 称为尾数</li>
<li>exponent 称为指数</li>
<li>float：
1bit（符号位） 8bits（指数位） 23bits（尾数位）
double：
1bit（符号位） 11bits（指数位） 52bits（尾数位）</li>
</ul>

复习：

<pre><code class="language-java ">float a=5.8;

5.8=1.45*2^2;

0 129 0.45
0 10000000 01 1100 1100 1100 1100 1100 1
</code></pre>

<blockquote>
  为了方便计算机比较大小，指数表示为127+exponent。比如2就是129
  
  科学技术法表示128 可以12.8 * 10 、1.28 * 10^2 、 0.128 * 10^3  IEEE754标准规定浮点数使用1.xx，因此1是被省略的。
  
  可以看出来float最大能表示的数取决于指数：2^2^8=3.4*10^38
</blockquote>

<h4>整型提升</h4>

Java定义了若干使用于表达式的类型提升规则：<br />
1）所有的byte型. short型和char型将被提升到int型<br />
2）如果一个操作数是long形 计算结果就是long型;<br />
3）如果一个操作数是float型，计算结果就是float型;<br />
4）如果一个操作数是double型，计算结果就是double型;

<blockquote>
  +=,++ 没有这个问题<br />
  byte a=1;<br />
  byte b=1;<br />
  byte c=a+b; //error
</blockquote>

<h4>ldc 指令</h4>

从运行时常量区取出int,double,String等类型，并将其压入操作数栈顶。

<h4>HashMap modCount</h4>

hashMap中使用modCount来维护多线程中同时遍历与修改同一个HashMap的快速失败机制。<br />
在JDK 1.7 中modCount是由volatile修饰的，但是1.8不再由这个关键字修饰。因为开发者觉得没有必要，且在单线程环境下消耗的性能太高。

相关连接：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6625725">Oracle Java Bug Database</a>

<h4>延迟初始化</h4>

HashMap 在初始化的时候，并没有为Node数组申请内存，而是放在了第一次put的时候进行resize操作。在平时开发也可以将有性能消耗的操作进行lazy initial

<h4>等号操作符</h4>

等号操作符会返回赋值的结果，比如

<pre><code class="language-java ">System.out.println(a=3);
</code></pre>

会返回3，这也是一种编程技巧，比如：

<pre><code class="language-java ">if((a=3)==4){

}
</code></pre>

会在比较过程中进行对a进行赋值

<h4>关闭逻辑运算的短路效果</h4>

有时候我们想要比较两个操作是不是都为false

<pre><code class="language-java ">    public static boolean getTrue() {
        System.out.println("运行getTrue方法");
        return true;
    }

    public static boolean getFalse() {
        System.out.println("运行getFalse方法");
        return false;
    }

    public static void main(String[] args){
       if (getTrue() || getFalse()){
           System.out.println("判断成功");
       }
    }

输出：
运行getTrue方法
判断成功
</code></pre>

我们都知道逻辑运算中会有短路操作，但是某些时候我们想要在判断的同时让两个方法都运行的话，一般会改成这样：

<pre><code class="language-java ">public static void main(String[] args){

       boolean isTure=getTrue();
       boolean isFalse=getFalse();
       if (isTure || isFalse){
           System.out.println("判断成功");
       }
    }
</code></pre>

虽然达到了效果，但是代码远不如上面的简洁，这个时候我们可以使用位运算：

<pre><code class="language-java ">    public static void main(String[] args){
       if (getTrue() | getFalse()){
           System.out.println("判断成功");
       }
    }
</code></pre>

一样能达到上面的效果

参见<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Oracle Java Doc 15.22.2</a>

<h4>快捷表示2的幂</h4>

程序中想要快捷表示2的幂，可以直接用位运算

<pre><code class="language-java ">int a =1&lt;&lt;3; //8
int a =1&lt;&lt;4; //16
</code></pre>

主要可用于表示大数字的时候，也不用担心性能，因为编译器会帮你转换为具体的值。

<h4>正则表达式</h4>

正则表达式在查找的时候不会复用以前的字符串，比如
\w\d\w
在匹配A1B2C3D的时候，会拿到<br />
A1B<br />
C3D<br />
的结果，而B2C会被丢失。

<h4>resize()方法</h4>

JDK1.7 中

<code>HashMap</code>在resize()扩容在多线程情况下可能会生成一个<strong>死循环</strong>链表、
详细:<br />
主要在于链表的重新排列。由于hash()与扩容带来的链表位置的不确定，<code>HashMap</code>为了保证性能，通过倒置排列链表的方法将原本复制一个链表需要O(n)的时间复杂度降低到了O(1)。

这样带来的问题就是多线程可能会生成一个死循环链表。

关键代码：

<pre><code class="language-java ">while(null != e) {
    Entry&lt;K,V&gt; next = e.next; //1
    if (rehash) {
        e.hash = null == e.key ? 0 : hash(e.key);
    }
    int i = indexFor(e.hash, newCapacity);
    e.next = newTable[i];
    newTable[i] = e;
    e = next;//2
}
</code></pre>

关键点：

<ul>
<li>提前获取了next</li>
<li>链表会倒置排列</li>
</ul>

<blockquote>
  比如a->b->c ,线程1提前记录a的下一个元素为b，也就是a->b,暂停执行线程2，线程2完全执行，链表变成了c->b->a，这个时候继续线程1，线程1执行b.next会发现b的next是元素a，就变成了a->b->a 就变成了无限循环。
</blockquote>

详解：<a href="https://www.jianshu.com/p/1e9cf0ac07f4">老生常谈，HashMap的死循环---占小狼</a>

而JDK1.8 解决了这个问题，关键点在于：

resize()操作都是以2的幂数进行扩容的，这样扩容后可以发现节点要么在原位置，要么在原位置乘以2的位置。这个时候我们可以申请两个节点，一个记录头，一个记录尾。每次替换节点的时候都把节点插入尾部，最后把数组指向头，这样就不会有倒置链表的问题了。

伪代码：将<code>node</code>链表按奇偶分开：

<pre><code class="language-java "><br />        Node&lt;Integer&gt; nHead = null, nTail = null;
        Node&lt;Integer&gt; oHead = null, oTail = null;
        Node&lt;Integer&gt; n = node;

        do {
            //偶数
            if (n.item % 2 == 0) {
                if (oHead == null) {
                    oHead = n;
                } else {
                    oTail.next = n;
                }
                oTail = n;
            } 
            //基数
            else {
                if (nHead == null) {
                    nHead = n;
                } else {
                    nTail.next = node;
                }
                nTail = n;
            }

        } while ((n = node = node.next) != null);
</code></pre>

<code>HashMap</code>只用维护两个这样的<code>nHead</code>节点即可。

<h4>正则表达式\w</h4>

\w 官方说明是匹配字母、数字、下划线、汉字。

但是具体是不是包括汉字，还是得依靠<strong>语言环境</strong>，<strong>操作系统</strong>等。\w涉及到汉字的时候不一定可靠。

<h4>PriorityQueue 优先队列</h4>

Java 官方文档：<code>PriorityQueue</code>在方法提供的迭代是<em>不</em>保证遍历优先级队列中的元素的任何特定顺序。如果您需要有序遍历，请考虑使用<code>Arrays.sort(pq.toArray())</code>这是因为当在迭代器是包含一个remove操作的，而迭代器在中执行<code>remove</code>操作时，可能会涉及到一个未访问的元素被移动到了一个已经访问过的节点位置.
相关连接：<a href="https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html">Java Docs PriorityQueue</a>

<h4>HashMap扩容</h4>

<code>hashMap</code>扩容时间复杂度是O(n)，n为<code>hashMap</code>已存的元素数量，一般为（length*0.75），并且使用默认的容量扩容刚开始是16，依次32,64,128因此如果会有大量的数据的话，尽量先指定容量大小，避免频繁扩容带来的性能消耗。并且Java 8 的hashMap性能比Java 7在各种情况下都高很多。

<h4>Static 初始化</h4>

静态变量<strong>初始化</strong>的时间为类加载过程的初始化阶段，类加载触发时间段为：

<ul>
<li>使用new 关键字实例化对象</li>
<li>调用某个类静态方法时</li>
<li>读取或设置类的静态字段</li>
<li>反射<code>Class.ForName()</code></li>
<li>初始化子类</li>
<li>虚拟机表明启动类</li>
</ul>

的时候，会触发。

而成员变量初始化发生在对象实例化的过程中。实例化对象需要：<strong>加载</strong>，<strong>连接</strong>，<strong>初始化</strong>完成后才能使用。注意是<strong>完成</strong>.

<strong>但是在初始化静态变量的时候一般也会带着其他类的实例化</strong>

比如：

<pre><code class="language-java ">public class B{
    public static A a=new A();
}
</code></pre>

这个时候在<strong>初始化</strong>类B的时候，会带着类A的对象的<strong>实例化</strong>。

再看：

<pre><code class="language-java ">public class B{
    public static B a=new B();
}
</code></pre>

这样写就会将B的实例化阶段提前到初始化阶段。

<pre><code class="language-java ">public class B{
    public static B a=new B();
    public static int a=1;

    public B(){
        System.out.println(a);
    }
}

public static void main(String[] args) {
    B b=new B();
} 
打印：
0
1
</code></pre>

这便是在初始化B的时候，提前将B的对象的实例化提前到了初始化阶段，而类B的整个初始化阶段还没完成，这样就导致了第一次输出默认初始化的值：0.

<strong>因此在写单例类定义instance字段的时候，最好写在所有static变量后面，防止在构造函数里面使用其他static字段，导致空指针异常</strong>

<h4>类初始化</h4>

<pre><code class="language-java ">public class Test {

    private int a=1;

    private int b;

    public Testt(){

        b=2;
    }
}
</code></pre>

<blockquote>
  javap -c Test.class
</blockquote>

<pre><code class="language-java ">  public Collection.Test();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: aload_0
       5: iconst_1
       6: putfield      #2                  // Field a:I
       9: aload_0
      10: iconst_2
      11: putfield      #3                  // Field b:I
      14: return
}

</code></pre>

可以看到，虽然Java初始化成员变量可以在定义的时候初始化，也可以在构造函数里面初始化，但是其实经过编译后可以发现，定义时初始化只是一个语法糖，最后编译出来的代码还是会按顺序转移到<strong>构造函数</strong>里面统一初始化，也就是说所有的成员变量的初始化都是通过构造方法初始化的]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>832</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:51:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:51:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[2018-10-12-hashmap%e3%80%81%e6%b5%ae%e7%82%b9%e6%95%b0%e3%80%81%e7%b1%bb%e5%88%9d%e5%a7%8b%e5%8c%96%e7%ad%89%e4%b8%aa%e4%ba%ba%e6%80%9d%e8%80%83]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Git各种命令归纳版</title>
		<link>http://dengchengchao.com/?p=834</link>
		<pubDate>Thu, 15 Nov 2018 12:52:40 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=834</guid>
		<description></description>
		<content:encoded><![CDATA[1.克隆：
单纯的克隆名字： git clone [url]
自定义新建项目名称： git clone [url] [项目名字]

2.跟踪文件：
git add [文件名]

3.添加忽略文件
使用DOS创建.gitignore文件  touch .gitignore

4.查看文件状态:
查看当前的文件状态： git status
查看已缓存文件中和未暂存文件中相同文件的差别：git diff 
查看已缓存文件中和已暂存文件中相同文件的差别：git diff --cached

5.git删除文件：
若是只删除本地文件，使用git status 后git会提醒你此文件已修改但是没有加入缓存。
删除本地文件并且让git不在追踪该文件:git rm [文件夹名字]
删除的文件已被add到缓冲中，在删除本地文件之后: git rm  -f [文件名字] 
仅仅删除git仓库中的跟踪目录，但是保留本地文件。 git rm --cached [文件名]
批量删除文件：使用glob模式：git rm long/&#42;log

6.移动文件
git并不追踪对文件的移动的操作
使用git 重命名文件：git mv file_from file_to
[此类对文件的移动操作，git本质是不追踪的，但是git 能将mv操作分解为：mv readme.txt readme git rm readme.txt git add readme]

7.git分支系列
git新建分支：git branch [分支名]
git快捷建立以前版本的分支：git branch [分支名] [版本编号]
git切换当前工作分支： git checkout [分支名] //切换分支记得让当前工作目录为clear
git新建分支并且切换当前工作分支： git checkout -b [分支名]
git分支合并：当前分支与[分支名]合并  git merge [分支名]
git删除分支：git branch -d [分支名]

git分支合并后标记冲突解决：git add [文件名]
git查看当前所有的分支：git branch
git查看已合并分支消息：git branch --merge
git查看未合并分支消息：git branch --no-merge
git查看分支的详细信息：git brach -v
git强行删除未合并的分支：git bracn -D [分支名]

8.git远程分支
git同步远程数据到本地仓库：git fetch [仓库名]
git将本地分支提交到远程分支上：git push [仓库名] [分支名]  <em>若远程仓库并没有此分支，自动创建
git本地分支上传到远程分支并重命名：git push [仓库名] [分支名]：[新分支名]
#因为从git上clone下来的项目只有master和本地的master关联的，分支并没有和本地分支关联。
git checkout [本地分支名] [远程分支名]
git删除远程分支：git push [仓库名] ：分支名
git修改远程分支关联仓库：$ git checkout --track origin/serverfix       /</em>同样得名字，不同的仓库*/
git修改本地分支的名字：$ git checkout -b sf origin/serverfix

9.git远程仓库
git关联远程仓库：git remote add origin [url]
git修改远程关联仓库：git remote origin set-url [URL]
git查看当前所有的远程仓库：git remote
git查看远程仓库所展示的信息：git remote show [origin]
git 查看远程仓库对应详细地址：git remote -v
git添加远程仓库：git remote add [仓库名]  [url]

10.git对远程仓库的操作
git 从远程仓库抓取数据到本地(包括分支)：git fetch [仓库名]    *fetch 只拉取数据，不进行合并
git设置本地分支远程分支关联后：git pull      *pull会自动合并数据

11.git推送数据
git推送数据到远程仓库：git push origin master 
git查看远程仓库的详细信息：git remote show [仓库名]

12.git 对远程仓库的修改
git重命名仓库： git remote rename [原本仓库名] [修改仓库名]
git远程删除仓库：git remote rm [仓库名]

13.git标签
git查看git的标签:git tag
git标签的删除：git tag -d 'v1.4.2.*'
git新建含附注的标签：git tag -a v1.4 -m "my version 1.4"
git查看标签信息：git show v1.4
git新建轻量级标签：git tag v1.4
git补加标签 git tag -a [标签名] [版本校验和]
git分享标签到远端服务器：git push [origin] [标签名]
git分享所有标签到远端服务器：git push [origin] --tags
git删除远程标签：git push origin --delete tag [标签名]  ||git push origin :refs/tags/标签名
git批量显示详细的标签信息：git tag -l v1.4.5

14.git快捷键别名
git修改命令快捷键：git config --global alias.[快捷键] [对应完成名]
//使用教学
git config --global alias.co commit
git co -m "message" 等同于 git commit -m "message"
git config --global alias.unstage 'reset HEAD --'
git unstage fileA 等同于 git reset HEAD fileA
git config --global alias.last 'log -1 HEAD'
git last 即可查看最后一次提交信息

15.git查看历史记录
git简单查看历史记录：git log
git查看简单的哈希值的历史记录：git log --abbrev--commit --pretty=oneline 
git查看分支详细信息：git show 
git查看详细信息加条件：git show master@{yesterday}
git查看信息中：^ 表示父提交
【详细历史看git log附加命令】

16.git撤销对文件的操作
git 补充commit文件：git commit --amend   【--amend只用补充文件，并且不用再次编写说明】
git取消对暂存区文件中的暂存：git reset HEAD [文件名]    （仅仅修改状态）
git取消对工作区文件的修改：git  checkout -- [文件名]   （回退到最近的commit或者add状态）

17.git配置文件系列
git设置用户信息：$ git config --global user.name "[用户名]"
                            $ git config --global user.email  [emal]
git设置默认文本编辑器：git config --global core.editor [编辑器]
git设置默认差异分析工具：$ git config --global merge.tool [工具名]
git查看配置信息：git config --list

18.git获取帮助
git获取帮助：git help  ||  git --help
git获取某个命令项的帮助：git help config

19.git衍合操作
衍合和合并的区别：合并是两个分支揉捏在一起，基本上是无序的，而衍合是分别按两个分支的修改时间有序的合并在一起，衍合最终会只有一个分支。两者的最终的结果是一样的，但是合并后的log是不一样的
git衍合分支:$ git rebase [需要衍合的分支名]
git切换分支基底：git rebase --onto [新基底] [以前的基底][需要换基底的分支] 
git快捷衍合分支：$ git rebase master server  （不用切到本分支再衍合）

20.git暂存
有时做一些改动以后，有突发情况，但是这个时候有又不想commit，可以使用存储-stash
git添加贮存区：git stash
git查看贮存区:git stash list
git恢复贮存区：git stash apply (此种恢复方式恢复后贮存区还存在，需要手动删除)
git删除贮存区：git stash drop
git恢复并删除贮存区：git stash po
git保存暂存作为一个新的分支：git stash branch

21.git查看日志技巧
 git可以使用点语法进行范围指明
 例如：
git 查看两个分支的区别：git log origin/master..HEAD（存在origin中但是不存在HEAD中的）
git查看存在A但是不存在B的提交：git log refB --not refA
git查看存在A或B但是不同时存在AB中的提交：git log A...B
语法：双点语法：A..B.存在A但是不存在B中的
          三点语法：A...B.存在A或B但是不同时存在A和B的

22.git Shell工具
git呼出git add工具：
git add -i

23.git 文件冲突处理工具
git add --patch/git add -p]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>834</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:52:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:52:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[git%e5%90%84%e7%a7%8d%e5%91%bd%e4%bb%a4%e5%bd%92%e7%ba%b3%e7%89%88]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>VIM使用技巧</title>
		<link>http://dengchengchao.com/?p=836</link>
		<pubDate>Thu, 15 Nov 2018 12:53:04 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=836</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>插入：</h2>

a        //在光标当前所在字符位置的后面输入文本数据。

A       // 在光标当前所在行的行尾（也即最后一个字符位置）后面输入文本数据。

i         //在光标当前所在字符位置的前面输入文本数据。

I        //在光标当前所在行的行首（也即在第一个非空白的起始字符）前面输入文本数据。

o       //在光标当前所在行下面的行首位置输入文本数据。

O       //在光标当前所在行上面的行首位置输入文本数据。

<h2>移动光标</h2>

在 vi 中, 移动光标和编辑是两件事, 正因为区分开来, 所以可以很方便的进行光标定

位和编辑. 因此能更快一点移动光标是很有用的.

w              移动光标到下一个单词开头.

e               移动光标到下一个单词结尾

b               移动光标到上一个单词.

0               移动光标到本行最开头.

^               移动光标到本行最开头的字符处.

$               移动光标到本行结尾处.

A               移动光标至行尾并处于“追加”状态，直接编辑

H               移动光标到屏幕的首行.

M               移动光标到屏幕的中间一行.

L               移动光标到屏幕的尾行.

gg              移动光标到文档首行.

G               移动光标到文档尾行.

:n              跳至第n行

ctrl + f        向下翻页 同 page down.

ctrl + b        向上翻页 同 page up.

ctrl + d        向下翻半页 此比较有用

ctrl + u        向上翻半页 此比较有用

ctrl + e        向下翻一行

ctrl + y        向上一行

[[              转到上一个位于第一列的“{”

]]              转到下一个位于第一列的“}”

{               转到上一个空行

}               转到下一个空行

''   两个单引号 此命令相当有用, 它移动光标到上一个标记处, 比如用 gd, * 等查找到某个单词后, 再输入此命令则回到上次停留的位置.

'.   一单一点   此命令相当好使, 它移动光标到上一次的修改行.

`.   一倒引一点 此命令相当强大, 它移动光标到上一次的修改点.

拷贝, 删除与粘贴

<hr />

在 vi 中 y 表示拷贝, d 表示删除, p 表示粘贴. 其中拷贝与删除是与光标移动命令

结合的, 看几个例子就能够明白了.

yw              表示拷贝从当前光标到光标所在单词结尾的内容.

dw              表示删除从当前光标到光标所在单词结尾的内容.

daw              表示删除光标所在的单词，不管光标在此单词那一位置

y0              表示拷贝从当前光标到光标所在行首的内容.

d0              表示删除从当前光标到光标所在行首的内容.

y$              表示拷贝从当前光标到光标所在行尾的内容.

d$[D]           表示删除从当前光标到光标所在行尾的内容.

特殊地:

yy              表示拷贝光标所在行.

dd              表示删除光标所在行.

D               表示删除从当前光标到光标所在行尾的内容.

xp              表示交换光标与其后的字符的位置

ddp             表示光标所在行与下一行交换

J               表示光标所在行与下一行合并]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>836</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:53:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:53:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[vim%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>正则表达式速查</title>
		<link>http://dengchengchao.com/?p=838</link>
		<pubDate>Thu, 15 Nov 2018 12:53:38 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=838</guid>
		<description></description>
		<content:encoded><![CDATA[<h4>元字符</h4>

元字符：出现在正则表达式中具有特殊含义的字符

单个元字符：

<pre><code class="">.   匹配除换行符以外的任意字符
\w  匹配字母、数字、下划线、汉字、
\s  匹配任意空白符（空格、制表符、换页等fnrtv）
\t  匹配制表符
\v  匹配垂直制表符
\d  匹配数字
\b  匹配单词开始或结束的位置
\n  匹配换行符
\r  匹配回车符



\W  匹配非字母、数字、下划线、汉字
\S  匹配任意一个非空白符字符
\D  匹配非数字
\B  匹配非单词开始或结束的位置
</code></pre>

特殊字符：不需要\即可表示特殊含义的字符

<pre><code class="">$   匹配字符串结束位置
^   匹配字符串开始位置
()  标记字表达式开始和结束的位置
*   匹配字表达式零次或多次

</code></pre>

限定符：多个元字符

<pre><code class="">[]   匹配其中的任意一个字符
[-]  匹配其中范围中的一个例如[a-zA-Z]a-z或A-Z的一个
[^x]匹配除x以外的任意字符
*    匹配零个或多个字符
+    匹配其中至少一个字符
？   匹配其中零个或者一个字符
{n}  重复n次 \\比如 d{2}=匹配两次d
{n,} 至少重复n次
{n,m}重复n到m次 
</code></pre>

分支

<pre><code class="">|    表示或 
()   括号里面看做一个字符

</code></pre>

贪婪匹配与非贪婪匹配

<pre><code class="">正则表达式后面加? 表示取最短情况。非贪婪匹配
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>838</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:53:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:53:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e9%80%9f%e6%9f%a5]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 注解Annotation初探</title>
		<link>http://dengchengchao.com/?p=840</link>
		<pubDate>Thu, 15 Nov 2018 12:54:30 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=840</guid>
		<description></description>
		<content:encoded><![CDATA[看<a href="https://github.com/spring-projects/spring-framework">Spring</a>和<a href="/home/citron/WorkSpace_Java/MyAutoValue/target/MyAutoValue-1.0-SNAPSHOT.jar">auto</a>源代码都包含了很多自定义的注解，想着想要深入学习，还是得先了解下注解(<code>Annotation</code>)

<h4>注解定义</h4>

注解是在JDK1.5 开始引入的新特征。
对于Java 开发者来说，或多或少都会接触到<code>@Override</code>,<code>@param</code>等注解，这些注解的功能都很熟悉。注解就好像一个标签一样，标明了这个类，方法，成员变量等应该具有的行为或作用。

<h4>注解原理</h4>

说到底，注解就好像一个<code>JavaBean</code>,举例来说:

<pre><code class="">@JSONField(name="test",unwarpped=true)
</code></pre>

相当于定义一个<code>JSONField</code>对象，这个对象的<code>name</code>属性为<code>test</code>,<code>unwarpped</code>属性为<code>true</code>.然后通过在定义注解<code>@Retention</code>属性说明在什么时候解析这个<code>JavaBean</code>，并通过实现接口，让编译器指定的时候执行一系列操作，比如依赖检查，文档生成等。

<h4>注解实战</h4>

<h5>首先我们需要明白一些关于注解的知识：</h5>

java.lang.annotation提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：

<ul>
<li><strong>@Retention:</strong> 定义该注解的生命周期

<ul>
<li><code>RetentionPolicy.SOURCE</code>: 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。<code>@Override</code>, <code>@SuppressWarnings</code>都属于这类注解。</li>
<li><code>RetentionPolicy.CLASS</code> : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li>
<li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li>
</ul></li>
<li><strong>@Target:</strong> 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType参数包括

<ul>
<li><code>ElementType.CONSTRUCTOR</code>:用于描述构造器</li>
<li><code>ElementType.FIELD</code>:成员变量、对象、属性（包括enum实例）</li>
<li><code>ElementType.LOCAL_VARIABLE</code>:用于描述局部变量</li>
<li><code>ElementType.METHOD</code>:用于描述方法</li>
<li><code>ElementType.PACKAGE</code>:用于描述包</li>
<li><code>ElementType.PARAMETER</code>:用于描述参数</li>
<li><code>ElementType.TYPE</code>:用于描述类、接口(包括注解类型) 或enum声明</li>
</ul></li>
<li><strong>@Documented:</strong> 一个简单的<code>Annotations</code>标记注解，表示是否将注解信息添加在<code>java</code>文档中。</p></li>
<li><p><strong>@Inherited:</strong> 定义该注释和子类的关系
 <code>@Inherited</code> 元注解是一个标记注解，<code>@Inherited</code>阐述了某个被标注的类型是被继承的。如果一个使用了<code>@Inherited</code>修饰的<code>annotation</code>类型被用于一个<code>class</code>，则这个<code>annotation</code>将被用于该class的子类。</p></li>
</ul>

<h5>实战:</h5>

<p>如何自定义注解，网上基本都有，不过都是一些简单的运行时注解，感觉就像定义了一个<code>JavaBean</code>,这里我们定义一个编译时注解。

首先定义一个注解类型：

<pre><code class="">package com.dengchengchao.annotationtest;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author dengchengchao
 * @date 18-7-26 下午5:44
 */
//定义注解生效时间段
@Retention(RetentionPolicy.CLASS)
//注解作用范围
@Target(ElementType.METHOD)
public @interface Annotation {
    int layoutId() default 0;
    int viewType() default 0;
    String viewHolder();
}

</code></pre>

然后定义一个处理此注解类型的注解处理器：

<pre><code class="">package com.dengchengchao.annotationtest;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import java.util.HashSet;
import java.util.Set;

/**
 * @author dengchengchao
 * @date 18-7-26 下午5:42
 */
//指定支持的注解
@SupportedAnnotationTypes("com.dengchengchao.annotationtest.Annotation")
//定义最低支持的jdk版本
@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class AnnotationProcessor extends AbstractProcessor {


    public AnnotationProcessor() {
      super();
    }

    //将需要支持的注解保存在Set中,用于注册此注解
    private Set&lt;String&gt; supportedAnnotationTypes = new HashSet&lt;String&gt;();

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        //获取标记注解的类名
        supportedAnnotationTypes.add(Annotation.class
                .getCanonicalName());
    }

    /**
     * 主要方法,此方法会根据注解定义的@Retention在指定的时间段执行
     *
     *
     * @param annotations 所有支持的注解类型
     * @param roundEnv 注解所在位置的周围环境信息,执行注解的时候主要从这个参数获取信息
     * @return 此处理器是否声明了这些注释类型,如果返回true,则表示后续处理器不必再处理此注解，返回false表示后面的处理器应该继续处理他们
     */
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations,
                           RoundEnvironment roundEnv) {
        Messager messager = processingEnv.getMessager();
        for (TypeElement typeElement : annotations) {
            for (Element element : roundEnv
                    .getElementsAnnotatedWith(typeElement)) {
                String info = "name = " + element.toString();
                messager.printMessage(Diagnostic.Kind.NOTE, info);
                //获取Annotation
                Annotation annotation = element
                        .getAnnotation(Annotation.class);

                if (annotation != null) {
                    int layoutId = annotation.layoutId();
                    int viewType = annotation.viewType();
                    String viewHolder = annotation.viewHolder();
                    messager.printMessage(Diagnostic.Kind.NOTE, "layoutId = " + layoutId
                            + ",viewType = " + viewType + ",viewHolder = "
                            + viewHolder);
                }

            }
        }
        return false;
    }


    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @Override
    public Set&lt;String&gt; getSupportedAnnotationTypes() {
        return supportedAnnotationTypes;
    }
}

</code></pre>

由于是编译时类型，我们必须告知编译器在编译的时候调用此注解处理器：

在项目工程的<code>resources/META-INF/services</code>目录下新建<code>javax.annotation.processing.Processor</code>文件，在文件中写明需要注册的注解处理器类(如果有多个处理器，则每个处理器占一行)

<pre><code class="">com.dengchengchao.annotationtest.AnnotationProcessor

</code></pre>

项目到这里就已经完成，可以使用工具打包为jar包，不过这里大多数都是<code>Maven</code>项目工程.贴出<code>POM</code>

<pre><code class=""><?xml version="1.0" encoding="UTF-8"?>
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.dengchengchao.MyAutoValue&lt;/groupId&gt;
    &lt;artifactId&gt;MyAutoValue&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;!--JDK配置--&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;mybatis-spring-boot&gt;1.2.0&lt;/mybatis-spring-boot&gt;
        &lt;java.version&gt;1.6&lt;/java.version&gt;
    &lt;/properties&gt;


    &lt;build&gt;
        &lt;plugins&gt;

            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;${java.version}&lt;/source&gt;
                    &lt;target&gt;${java.version}&lt;/target&gt;
                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;
                    &lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>

<blockquote>
  注意到后面必须添加编译选项 <code>-proc:none</code>
</blockquote>

到此为止，编译形注解完成
新建一个类，添加一个方法：

<pre><code class=""> package com.dengchengchao.annotationtest;

/**
 * @author dengchengchao
 * @date 18-7-26 下午6:01
 */
public class Main {

    @Annotation(layoutId = 100,viewType = 1,viewHolder = "com.dengchengchao.test")
    public void fun(){

    }


}
</code></pre>

编译此java文件：

<pre><code class="">javac -cp  MyAutoValue-1.0-SNAPSHOT.jar Main.java 
</code></pre>

输出结果如下：

<pre><code class="">Note: name = fun()
Note: layoutId = 100,viewType = 1,viewHolder = com.dengchengchao.test
</code></pre>

参考文章：<br />
<a href="https://www.jianshu.com/p/8e530d51cf39">深入Dagger:自定义AutoValue</a>

<a href="https://blog.csdn.net/nupt123456789/article/details/51018352">Java自定义AnnotationProcessor处理自己的Annotation</a>

<a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解Annotation实现原理与自定义注解例子</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>840</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 20:54:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 12:54:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-%e6%b3%a8%e8%a7%a3annotation%e5%88%9d%e6%8e%a2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 8 之 函数式编程与Lambda表达式 入门到深入 (一)</title>
		<link>http://dengchengchao.com/?p=850</link>
		<pubDate>Thu, 15 Nov 2018 13:19:50 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=850</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>前言</h3>

最近看《Effective Java》里面提到了很多关于Java 8的特性，听的最多的也是Lambda、函数式编程。看了很多文章和资料，现做一个总结。

本文以是什么，为什么，怎么使用为主线，详细介绍Java 8新特性之函数式编程，争取在读者读完本文后，对函数式编程有一个清楚的认识。

<h3>函数式编程是什么</h3>

<h4>1. 引入：函数式编程</h4>

情景A:<br />
设计一个工具类，这个类包含两个方法，一个是能求两个参数之间的和，一个是两个参数之间的差

<pre><code class="">//求和
public static int getSum(int begin,int end){
    assert(begin&lt;end);
    int sum=begin;
    for(int i=begin+1;i&lt;end;i++){
       sum+=i;  
    }
    return sum;
}

//求积
public static int getPro(int begin,int end){
    assert(begin&lt;end);
    int pro=begin;
    for(int i=begin+1;i&lt;end;i++){
        pro*=i;
    }
    return pro;
}
</code></pre>

仔细看以上代码，我们发现两个方法之间，真正不同的，只有一行代码！
读者不妨思考下，如果是你，应该怎么优化上面的代码？<br />
看以下代码：

<pre><code class="">//通用方法
public static int commonOperate(BinaryOperator&lt;Integer&gt; operator, int begin, int end) {
    assert (begin &lt; end);
    int result = begin;
    for (int i = begin + 1; i &lt; end; i++) {
        result = operator.apply(i, result);
    }
    return result;
}

//求和
public static int getSum(int begin,int end){
    return commonOperate(Integer::sum,begin,end);
}

//求积
public static int getPro(int begin,int end){
    return commonOperate((x,y)-&gt;x*y,begin,end);
}
</code></pre>

是的，没有任何重复的代码，并且这样的代码，对以后的方法扩展很方便，我们只需要修改传入的lambda方法即可。<br />
在没有事先了解什么是lambda和函数式编程之前，可能会看不懂以上的代码，下面解释一下上面的代码，让读者体会lambda和函数式编程的神奇之处。

<ul>
<li>在代码没有优化之前，我们发现两个方法仅仅在于<code>sum+=i</code>和<code>pro*=i</code>不同，而类似对于<code>sum</code>和<code>pro</code>的具体操作，我们称为<strong>方法</strong>。</li>
<li>假设我们能将<strong>方法</strong>(function)作为一个参数传递进去，那么问题便迎刃而解。
<code>sum=function(sum,i);   //具体的行为，根据传入的function而定。</code></li>
<li>在优化后的代码中，我们便传入了一个函数式参数(也就是<code>lambda</code>)，用来控制对结果的操作。</li>
</ul>

也就是说：在Java 8 中，允许使用函数式编程，也就是允许将函数(方法)作为一个变量传递到其他的方法中，通过上面的优化就能看见具体的应用场景。

<blockquote>
  如果你学过C++，那么直接参考传递函数指针即可。
</blockquote>

那这和lambda表达式又有什么联系呢？

<blockquote>
  Lambda 表达式”(lambda expression)是一个匿名函数  ---百度百科
</blockquote>

看到lambda的定义，我们很自然就能和匿名类联系起来，匿名类就是一个只使用一次，并且没有名字的类。lambda表达式便是这样的函数。<br />
再回到上面的代码，如果没有<code>lambda</code>表达式。那么我们的代码是这样的：

<pre><code class="">//求积
public static int getPro(int begin,int end){
    int product(int x,int y){return x*y;}  //这是错误的语法，仅仅用来举例
    return commonOperate(product,begin,end);
}
</code></pre>

这样的语句看起来混乱，而且远没有lambda简洁，可读。

<strong>总结：</strong> lambda 表达式是为了和函数式编程相辅相成，函数式编程意味着可以将函数作为一个参数传入方法中，lambda表达式便是在传参时所定义的匿名函数。

<hr />

<h4>官方定义</h4>

<ol>
<li>在函数式编程中，函数也被归纳为<strong>第一等公民</strong>

<blockquote>
  一等公民的定义在《C++ primer》中提到过，指的是像基本数据类型一样能够被定义，传递，赋值等。
</blockquote></li>
<li>Java 中，要求函数式编程中的函数必须为<strong>纯函数</strong><br />
纯函数指的是：

<ul>
<li>不依赖外部系统状态，任何时候，只要输入一样，输出总是不变</li>
<li>函数的执行不影响外部程序的状态。(类似不改变成员变量，全局b变量等)</li>
</ul></li>
</ol>

在这里顺便提函数编程的优点：

<ol>
<li>可以利用Memoization技术提升性能<br />
Memoization技术指的是在第一次计算了一个输入的结果以后，下次遇到相同的输入，就直接放回结果，免去了再次计算的过程，能够提升程序性能。而这一点利用的是纯函数的输入相同，输出必然相同的特点。

<blockquote>
  有点像Java的自动装箱
</blockquote></li>
<li>可以延迟求值(Lazy Evaluation)<br />
延迟求值指的是表达式在真正被使用的时候才进行求值。
比如：

<pre><code class="">void test(boolean flag,String str){
   if(flag){
       System.out.println(str);
   }
}

test(false,"1"+"2"+"3");
</code></pre>

在延迟求值的情况下，<code>"1"+"2"+"3"</code>是不会被计算的。

<blockquote>
  有点类似逻辑运算的运算短路的情况
</blockquote></li>
</ol>

<h3>为什么要使用函数式编程</h3>

参考资料：<br />
<a href="https://www.jianshu.com/p/390147c78967">可能是最好的函数式编程入门</a><br />
<a href="http://www.importnew.com/24300.html">Java8 学习笔记</a><br />
<a href="https://www.cnblogs.com/heimianshusheng/p/5672641.html">Java 8中一些常用的全新的函数式接口</a><br />
<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">函数式编程初探</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>850</wp:post_id>
		<wp:post_date><![CDATA[2018-11-15 21:19:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-15 13:19:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-8-%e4%b9%8b-%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%b8%8elambda%e8%a1%a8%e8%be%be%e5%bc%8f-%e5%85%a5%e9%97%a8%e5%88%b0%e6%b7%b1%e5%85%a5-%e4%b8%80]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java  File,Path,Files总结</title>
		<link>http://dengchengchao.com/?p=863</link>
		<pubDate>Mon, 19 Nov 2018 09:41:16 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=863</guid>
		<description></description>
		<content:encoded><![CDATA[<h4>Java File 类</h4>

<em>定义Java虚拟机的接口和类，以访问文件，文件属性和文件系统。</em>

<ol>
<li>字段：
  File类中包含4个public静态字段，并且这4个字段比较相近:</li>
</ol>

<ul>
<li>pathSeparator         //与系统相关的路径分隔符，返回String</p></li>
<li><p>pathSeparatorChar     //与系统相关的路径分隔符，返回Char</p></li>
<li><p>separator             //系统相关的默认名称分割符，返回String</p></li>
<li><p>separatorChar        //系统相关的默认名称分隔符。返回Char

由此可以看出来，这4个字段主要分为两个：<code>pathSeparator</code>和<code>separator</code>
区别在于：<code>pathSeparator</code>用于处理在多个路径下的文件分割符，比如在Windows环境变量下，每个环境变量是以;分割开来，比如：<code>C:\test;C:\java</code>，而在Unix中却是以:分割。因此<code>pathSeparator</code>可以理解为多个路径分割符。
而<code>separator</code>用于处理在某个路径表示的分隔符，比较明显的就是Windows是以“\”分割：比如<code>C:\\test</code>，而Unix以“/”分割:<code>/home/test</code>。
使用这两类符号表示路径，能够使编写出来的代码跨平台使用也没有什么问题。

在Java官方文档中，标明File类是用来访问文件，文件属性和文件系统相关的，并且File类是无法访问File的具体内容的。
下面列举下File类中比较有用的方法：</p></li>
</ul>

<pre><code class="language-java ">  createNewFile()     //当且仅文件不存在的时候，创建新的文件
  createTempFile(String prefix,String suffix)    //在默认临时文件目录中创建一个空文件，使用给定的前缀和后缀生成其名称

  //此方法在不用指定路径,因为默认使用的系统Temp文件夹，也就是临时文件夹，生成的文件名一般不会重复，可以看做是类似：前缀+uuid+后缀

  createTempFile(String prefix,String suffix,File directory) //在指定的路径下生成临时文件，和两个参数的区别在于不再临时Temp文件夹中生成
  delete()           //删除文件或目录
  deleteOnExit()     //在虚拟机退出的时候删除文件或目录
  getAbsolutePath()   //获取此抽象路径名的绝对形式
  getCanonicalFile()  //获取此抽象路径的名的规范形式
  getPath()           //获取此抽象路径名转换为路径名字符串。
  //getPath(),getAbsolutePath(),getCanonicalPath() 
  //三个方法分别在于使用相对路径的时候表现不同
  //Path path=new Path(".");
  //getPath();                输出 .
  //getAbsolutPath();  输出D:\test\.
  //getCanonicalPath() 输出D:\test
  //并且值得注意的是：只有getCanonicalPath()是能正确解析相对路径的，而其他方法：getPath(),getName(),getParen()等是无法解析相对路径的。

  isAbsolute()  //测试此路径是否为绝对路径
  isDirectory() //测试此路径是否是文件夹
  list()        //返回此路径下表示的目录的中的所有文件和目录
  list(FilenameFilter filter) //使用过滤器过滤文件和目录
  toURI()       //返回由此路径表示的URI
  toPath()      //返回NIO的Path对象

</code></pre>

<hr />

<h4>Path</h4>

<p>值得注意的是在JDK1.7 中，增加了NIO Path对象，用于增强File。

值得注意的方法有：

<pre><code class="language-java ">Paths.get()                   //NIO Path的默认构造函数，注意Path默认构造函数是private的
endWith(Path other)           //路径是否是以other结束 
startWith(Path other)         //路径是否是以other开始
getName(int index)            //获取索引为index的目录或者名称（根目录不算）

//注意，和getName(index)配套的有getNameCount() ，获取元素个数，因此可以使用for循环来访问它。它还有一个迭代器方法```itertor()```,也可以使用迭代器访问。

normalize()                    //返回格式化路径，一般使用方式为调用toAbsolutePath()后调用此方法
resolve()                       //相当于拼接两个路径
resolveSibling()                //从this的父路径拼接此路径
relativize(Path other)          //返回此路径到给定路径的相对路径
toRealPath(LinkOption... options)//相当于File.getCanonicalFile() 也就是toAbsolutePath()+normalize()
</code></pre>

值得一提的是NIO Path中新添加了一个非常有用的方法便是<code>register(WatchService watcher, WatchEvent.Kind&lt;?&gt;... events)</code>,它能够注册监控文件，当文件被修改，新建，删除的时候，都能够第一时间被发现。

<strong>Demo</strong>

<pre><code class="language-java ">  public static void main(String[] args) throws IOException, InterruptedException {
          WatchService watchService = FileSystems.getDefault().newWatchService();

          String filePath = "D:/test";

          Paths.get(filePath).register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
                  StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE);

          while(true){
              WatchKey key = watchService.take();
              List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = key.pollEvents();
              for (WatchEvent&lt;?&gt; event : watchEvents) {
                  if(StandardWatchEventKinds.ENTRY_CREATE == event.kind()){
                      System.out.println("创建：[" + filePath + "/" + event.context() + "]");
                  }
                  if(StandardWatchEventKinds.ENTRY_MODIFY == event.kind()){
                      System.out.println("修改：[" + filePath + "/" + event.context() + "]");
                  }
                  if(StandardWatchEventKinds.ENTRY_DELETE == event.kind()){
                      System.out.println("删除：[" + filePath + "/" + event.context() + "]");
                  }

              }
              if(!key.reset()){
                  break;
              }
          }
      }
</code></pre>

<hr />

<h4>Files</h4>

NIO中，与Path配套使用的还有Files类，下面简单列出几个比较实用的方法：

<pre><code class="language-java ">Files.exists()               //文件是否存在
Files.createDiretory()       //创建新的文件夹
Files.copy()                 //复制一个文件到另外一个地方 
Files.copy(Path,Path,StandardCopyOption.REPLACE_EXISTING); //复制文件，当目标文件已存在的时候，覆盖目标文件
Files.move()                 //移动文件
//在之前要完成这个功能，只能使用File#rename()方法
Files.delete()               //删除文件
</code></pre>

<code>Files.walkFileTree()</code>     //递归遍历文件目录

一般用于查找某个指定文件。看例子：

<pre><code class="language-java "> public static void main(String[] args)throws Exception {
        Path startingDir = Paths.get("G:\\test");
        List&lt;Path&gt; result = new LinkedList&lt;&gt;();
        Files.walkFileTree(startingDir, new FindJavaVisitor(result));
        System.out.println(result);

    }

    private static class FindJavaVisitor extends SimpleFileVisitor&lt;Path&gt;{
        private List&lt;Path&gt; result;
        FindJavaVisitor(List&lt;Path&gt; result){
            this.result = result;
        }
        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs){
            if(file.toString().endsWith(".java")){
                result.add(file.getFileName());
            }
            return FileVisitResult.CONTINUE;
        }
    }
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>863</wp:post_id>
		<wp:post_date><![CDATA[2018-11-19 17:41:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-19 09:41:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-filepathfiles%e6%80%bb%e7%bb%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="file"><![CDATA[File]]></category>
		<category domain="post_tag" nicename="files"><![CDATA[Files]]></category>
		<category domain="post_tag" nicename="path"><![CDATA[Path]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>说说switch关键字</title>
		<link>http://dengchengchao.com/?p=879</link>
		<pubDate>Mon, 26 Nov 2018 10:36:28 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=879</guid>
		<description></description>
		<content:encoded><![CDATA[<h4>Switch语法</h4>
<code>switch</code>作为Java内置关键字，却在项目中真正使用的比较少。关于<code>switch</code>，还是有那么一些<strong>奥秘</strong>的。
<h5>要什么switch，我有if-else</h5>
确实，项目中使用<code>switch</code>比较少的一个主要原因就在于它的作用能被<code>if-else</code>代替，况且<code>switch</code>对类型的限制，也阻碍了<code>switch</code>的进一步使用。

先看看<code>switch</code>的语法：
<pre><code class="java">switch(exp){
    case exp1:
        break;
    case exp2:
        break;
    default:
        break;
}
</code></pre>
其中<code>exp</code>的类型限制为：<code>byte ,short , int ,  char,</code>及其包装类，以及枚举和<code>String</code>(JDK1.7)
<h4>为什么要有这些限制？</h4>
如果说，<code>switch</code>的功能和<code>if-else</code>的一模一样，那么它存在的意义在哪里？

答案是：<code>switch</code>和<code>if-else</code>在设计的时候，是有一定的性能差别的。

看代码：
<pre><code class="java">public class Test {

    public static void switchTest(int a) {

        switch (a) {
            case 1:
                System.out.println("1");
                break;
            case 2:
                System.out.println("2");
                break;
            default:
                System.out.println("3");
                break;
        }
    }
}

</code></pre>
<pre><code class="java">javap  -c Test.class
</code></pre>
结果如下：
<pre><code class="java">  public static void switchTest(int);
    Code:
       0: iload_0
       1: lookupswitch  { // 2
                     1: 28
                     2: 39
               default: 50
          }

    ...

</code></pre>
这里面省略一些代码。

可以发现，<code>switch</code>是通过<code>lookupswitch</code>指令实现。那么<code>lookupswitch</code>指令是干嘛的呢？

在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.10">Java se8</a>文档中的描述可以大概知道：

<code>switch</code>可以被编译为两种指令
<ul>
 	<li><code>lookupswitch</code>：当<code>switch</code>的<code>case</code>比较稀疏的时候，使用该指令对<code>int</code>值的<code>case</code>进行一一比较，直至找到对应的<code>case</code>（这里的查找，可以优化为二分查找）</li>
 	<li><code>tableswitch</code>：当<code>switch</code>的<code>case</code>比较密集的时候，使用<code>case</code>的值作为<code>switch</code>的下标，可以在时间复杂度为O(1)的情况下找到对应的<code>case</code>(可以类比HashMap)</li>
</ul>
并且文档中还有一段描述：
<blockquote>Java虚拟机的<code>tableswitch</code>和 <code>lookupswitch</code>指令仅对<code>int</code>数据有效。因为对 <code>byte</code>，<code>char</code>或或<code>short</code>值的操作在内部被提升为<code>int</code>，所以对其<code>switch</code>表达式求值为其中一个类型进行编译，就好像它被计算为要键入一样<code>int</code>。如果 <code>chooseNear</code>方法是使用type编写的，则使用类型时 <code>short</code>将生成相同的Java虚拟机指令<code>int</code>。其他数字类型必须缩小到类型<code>int</code> 以便在a中使用<code>switch</code>。</blockquote>
现在，我们应该能够明白，为什么<code>switch</code>关键字会有类型限制了，因为<strong><code>switch</code>所被翻译的关键字是被限制为int类型的</strong>，至于为什么是int，我猜应该是基于性能和实现的复杂度的考量吧。
<h4>int之外的类型</h4>
我们明白了<code>byte,shor,char,int</code>能被作为<code>switch</code>类型后，再看看枚举和<code>String</code>
<pre><code class="java">public static void switchTest(String a) {

        switch (a) {
            case "1":
                System.out.println("1");
                break;
            case "2":
                System.out.println("2");
                break;
            default:
                System.out.println("3");
                break;
        }
    }
</code></pre>
编译生成Test.class。拖入IDEA进行反编译得到如下代码：
<pre><code class="java">   public static void switchTest(String a) {
        byte var2 = -1;
        switch(a.hashCode()) {
        case 49:
            if (a.equals("1")) {
                var2 = 0;
            }
            break;
        case 50:
            if (a.equals("2")) {
                var2 = 1;
            }
        }

        switch(var2) {
        case 0:
            System.out.println("1");
            break;
        case 1:
            System.out.println("2");
            break;
        default:
            System.out.println("3");
        }

    }
</code></pre>
可以看见，JDK7 所支持的<code>String</code>类型是通过获取<code>String</code>的hashCode来进行选择的，也就是本质上还是int.为什么<code>String</code>可以这样干？这取决于<code>String</code>是一个不变类。
<blockquote>为了防止hash碰撞，代码更加保险的进行了<code>equals</code>判断。</blockquote>
再来看看<code>Enum</code>
<pre><code class="java">public static void switchTest(Fruit a) {
    switch (a) {
        case Orange:
            System.out.println("Orange");
            break;
        case Apple:
            System.out.println("Apple");
            break;
        default:
            System.out.println("Banana");
            break;
    }

}
</code></pre>
编译生成Test.class。拖入IDEA进行反编译得到如下代码：
<pre><code class="java">    public static void switchTest(Fruit a) {
        switch(1.$SwitchMap$com$dengchengchao$Fruit[a.ordinal()]) {
        case 1:
            System.out.println("Orange");
            break;
        case 2:
            System.out.println("Apple");
            break;
        default:
            System.out.println("Banana");
        }

    }
</code></pre>
可以看到，枚举支持<code>switch</code>更加简单，直接通过枚举的顺序即可作为相关<code>case</code>

总之：
<ul>
 	<li><code>switch</code>的设计按道理来说，是比<code>if-else</code>要快的，但是在99.99%的情况下，他们性能差不多，除非<code>case</code>分支量巨大,但是在<code>case</code>分支过多的情况下，一般应该考虑使用多态重构了。</li>
 	<li><code>switch</code>虽然支持<code>byte,int,short,char,enum,String</code>但是本质上都是<code>int</code>，其他的只是编译器帮你进行了语法糖优化而已。</li>
</ul>
<blockquote>尊重劳动成果，转载注明出处</blockquote>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>879</wp:post_id>
		<wp:post_date><![CDATA[2018-11-26 18:36:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-26 10:36:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%af%b4%e8%af%b4switch%e5%86%85%e5%b9%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="java-%e8%af%ad%e6%b3%95"><![CDATA[Java 语法]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="post_tag" nicename="switch"><![CDATA[switch]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 编码那些事（二）</title>
		<link>http://dengchengchao.com/?p=887</link>
		<pubDate>Mon, 26 Nov 2018 11:37:42 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=887</guid>
		<description></description>
		<content:encoded><![CDATA[<h5>Java中有哪些编码</h5>
建议首先阅读<a href="http://dengchengchao.com/?p=793">Java 编码那些事(一)</a>

上一篇文章中，说到了编码的分类。现在说说java中的实际运用。在使用<code>tomcat</code>的时候，绝大部分同学都会遇到乱码的问题，查查文档，google一下解决方案啥的，都是设置这里，设置那里，或者在代码中添加编码方式，虽然最终问题解决了，但是你真的知道这是什么意思么？

在平时开发Java的时候，我们会遇到很多编码设置，其中包括：
<ul>
 	<li>Java文件的编码：Java文件的编码表示编写代码得时候，<code>.java</code>文件本身的编码，这个编码的影响在于将你的写的代码源文件复制一份，使用其他编辑器打开，若两个编辑器的默认编码方式不一样，则打开源文件就会变成乱码。一般英文的影响不大，因为大多数编码都兼容<code>ASCII</code>编码，但是中文要是编码不正确，则会乱码。IDEA的设置在：Setting-&gt;Editor-&gt;File Encodings中设置</li>
 	<li>JVM编码：JVM编码表示JVM在读取<code>String</code>类型的默认编码，可以使用<code>Charset.defaultCharset().name()</code> 获取。可以在JVM启动参数中使用<code>-Dfile.encoding=UTF-8</code>进行设置。</li>
</ul>
一般需要区分的就是这两种编码。下面着重说下JVM编码的体现。
<h4>字节流与字符流</h4>
熟悉IO的同学应该都明白这两个流的区别。一般会出现字符乱码都在于需要与其他程序进行IO的时候。

先看看使用字节流进行读取文件的时候：
<pre><code class="java">    public static void main(String[] args){
        String path="G:\\test.txt";

        try(BufferedInputStream inputStream=new BufferedInputStream(new FileInputStream(path))) {
            for (byte bytes[] = new byte[1024]; inputStream.read(bytes) != -1; ) {
                String context = new String(bytes);
                System.out.println(context);
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
</code></pre>
然后再G盘新建一个文本文件，输入一段文字。使用默认的格式保存。

可以查看输出：
<pre><code class="java">�����ļ��ļ�                                                                         
</code></pre>
乱码了，下面来分析一下：

首先这里是JVM运行时的编码，因此和JVM的编码设置有关。打印JVM目前的编码设置：
<pre><code class="java">System.out.println(Charset.defaultCharset().name());
输出：UTF-8
</code></pre>
找到刚刚新建的文件test.txt，点击另存为，可以发现默认编码为<code>ANSI</code>，前一篇文章中说过，<code>ANSI</code>作为windows系统中的特殊存在，它在简体中文编码的情况下默认为<code>GB2312</code>编码。这便是乱码的原因，解决方案有两种：
<ol>
 	<li>设置JVM启动项：-Dfile.encoding=GB2312</li>
 	<li>在编码byte数组的时候，指定<code>GB2312</code>编码:<code>String context = new String(bytes,"GB2312");</code></li>
</ol>
<blockquote>这里推荐第二种，毕竟UTF8更加通用</blockquote>
问题完美解决。

同理，网络IO也能通过以下方法解决。

<strong>看明白了上面的发现问题和解决问题的流程的同学，下次遇到文件编码的问题，结合上一篇文章对编码的讲解，详细应该能够独立解决问题。</strong>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>887</wp:post_id>
		<wp:post_date><![CDATA[2018-11-26 19:37:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-26 11:37:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-%e7%bc%96%e7%a0%81%e9%82%a3%e4%ba%9b%e4%ba%8b%ef%bc%88%e4%ba%8c%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<category domain="post_tag" nicename="%e7%bc%96%e7%a0%81"><![CDATA[编码]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>14</wp:comment_id>
			<wp:comment_author><![CDATA[Java 编码那些事(三) 实战解决IDEA+Tomcat+Servlet 乱码问题 &#8211; 邓承超的个人博客]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://dengchengchao.com/?p=941</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[94.191.15.206]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-12-14 15:42:50]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-12-14 07:42:50]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] Java编码那些事(二) [&#8230;]]]></wp:comment_content>
			<wp:comment_approved><![CDATA[trash]]></wp:comment_approved>
			<wp:comment_type><![CDATA[pingback]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
				<wp:meta_value><![CDATA[0]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
				<wp:meta_value><![CDATA[1544773379]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>不要猜，要测试！---Java 微基准测试框架 JMH</title>
		<link>http://dengchengchao.com/?p=892</link>
		<pubDate>Wed, 28 Nov 2018 13:43:02 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=892</guid>
		<description></description>
		<content:encoded><![CDATA[在以前，想要知道自己写的程序性能和程序运行时间，一般都是定义一个<code>startTime=System.nanoTime</code>,再定义一个<code>endTime=System.nanoTime</code>，最后他们之间的差便是程序的运行时间。

但是，这样的测试仅仅是粗略的测试此段代码在此时的运行时间，结果并不一定可靠。这里建议使用一个更加官方的测试工具：JMH--Java微基准测试框架
<h3>Code Tools: jmh</h3>
JMH是由OpenJDK官方发布的一种Java工具，用于构建，运行和分析用Java和其他语言编写的针对JVM的nano / micro / milli / macro基准测试。

官方地址:https://openjdk.java.net/projects/code-tools/jmh/

使用JMH,你可以：
<ul>
 	<li>当需要优化一个方法的时候，可以使用JMH测试方法运行时间，测试是否达到优化效果</li>
 	<li>当需要知道一个方法大概的执行时间的时候</li>
 	<li>当需要知道不同的参数对同一个方法的运行效率的影响的时候</li>
</ul>
总之，JMH在方法级别的运行时间测试上得到的结果是比较权威的。
<h3>Go Start</h3>
官方推荐JMH应该使用Maven构建。
<ul>
 	<li>当我们仅仅需要测试一个独立的方法的时候，我们可以直接构建一个JMH Maven骨架（archetype）</li>
</ul>
<pre><code class="java">mvn archetype：generate \ 
          -DinteractiveMode = false \ 
          -DarchetypeGroupId = org.openjdk.jmh \ 
          -DarchetypeArtifactId = jmh- java -benchmark-archetype \ 
          -DgroupId = org.sample \ 
          -DartifactId = test \ 
          -Dversion = 1.0
</code></pre>
<ul>
 	<li>当我们想在已有到的项目的基础上进行JMH测试的时候，我们可以直接添加Maven依赖：
<pre><code class="html">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
  &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;
  &lt;version&gt;${jmh.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
  &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;
  &lt;version&gt;1.21&lt;/version&gt;
  &lt;scope&gt;${jmh.version}&lt;/scope&gt;
&lt;/dependency&gt;


</code></pre>
</li>
</ul>
添加完依赖后，我们就可以编写性能测试方法，这里和我们经常使用的单元测试方法差不多：

这里我们测试下HashMap中，使用位运算代替取模运行的效率到底有没有提升
<pre><code class="java">@BenchmarkMode(Mode.Throughput)
@Warmup(iterations = 3)
@Measurement(iterations = 10, time = 5, timeUnit = TimeUnit.SECONDS)
@Threads(8)
@Fork(2)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@State(Scope.Benchmark)
public class Test {

    @Param({"18","2035","12345"})
    private int param;

    @Benchmark
    public  void test(){
        int c=(16-1)&amp;param;
    }

    @Benchmark
    public  void  test2(){
       int c=param%16;
    }

    @Setup
    public void prepare() {
    }
}
</code></pre>
执行：

执行方式分两种
<ul>
 	<li>由于JMH测试一般测试好几轮取平均值，因此有时候测试时间比较长，这个时候我们可以使用Maven将测试打包，然后放在服务器上测试：<code>mvn clean package</code>

然后会在对应的目录/target下生成jar包，直接

<code>java -jar xxx.jar</code>

运行即可。</li>
 	<li>对于比较小的项目，我们可以直接编写Main方法，在编译器上运行即可：
<pre><code class="java">  public static void main(String[] args)throws Exception {
      Options options = new OptionsBuilder()
              .include(Test.class.getSimpleName())
              .output("G:/Benchmark.log")
              .build();
      new Runner(options).run();
  }
</code></pre>
这里我们指定了测试类和日志输出路径。

执行完成后可以获取测试结果：
<pre><code class="java"># JMH version: 1.21
# VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13
# VM invoker: H:\java\jdk1.8\jre\bin\java.exe
# VM options: -Dvisualvm.id=789216946682180 -javaagent:H:\idea\IntelliJ IDEA 2018.2.2_2\lib\idea_rt.jar=64857:H:\idea\IntelliJ IDEA 2018.2.2_2\bin -Dfile.encoding=UTF-8
# Warmup: 3 iterations, 10 s each
# Measurement: 10 iterations, 5 s each
# Timeout: 10 min per iteration
# Threads: 8 threads, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: com.dengchengchao.Test.test
# Parameters: (param = 18)
...
...
...

Benchmark   (param)   Mode  Cnt         Score        Error   Units
Test.test        18  thrpt   20  11201407.357 ± 288038.173  ops/ms
Test.test      2035  thrpt   20  11155849.134 ± 411417.605  ops/ms
Test.test     12345  thrpt   20  11242387.836 ± 124937.944  ops/ms
Test.test2       18  thrpt   20  10618259.409 ± 166619.563  ops/ms
Test.test2     2035  thrpt   20  10566613.381 ± 185395.887  ops/ms
Test.test2    12345  thrpt   20  10497633.170 ± 226031.760  ops/ms
</code></pre>
可以发现，结果中说明了每个方法的平均吞吐量以及误差范围等，我们可以得到结果：在我的电脑中，JDK 1.8环境下，使用Java 的位运算和取模运行时间相差不大，</li>
</ul>
<strong>在这里，使用JMH测试方法运行就算完成了，</strong>其实也比较简单，并且比自己写<code>System.nanoTime</code>更加准确。
<h3>注解介绍</h3>
在上面的方法测试中，我们发现了很多新的注解。下面对上这些注解进行简单介绍：
<h5>@Benchmark（测试方法标记注解）</h5>
标记测试方法，和@Test注解差不多，标注后在运行的时候JMH将会对此 方法进行测试。
<blockquote>在<a href="https://hg.openjdk.java.net/code-tools/jmh/file/66fb723292d4/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_01_HelloWorld.java">官方的HelloWorld例子</a>仅仅使用了这一个注解，因为这里的注解其实也是一种启动参数，不仅仅可以通过注解表示，还可以使用类似<code>java -jar xxx.jar -f 1 -t 2</code>方式指定，也可以在编写Main方法的时候，使在构建方法Builder的时候指定。这种灵活的参数指定方式，可以在不同的场景的灵活应用。</blockquote>
<strong>@BenchmarkMode(基准测试类型)</strong>
<ul>
 	<li>Throughput : 吞吐量，比如：1s内可以执行多少次调用</li>
 	<li>AverageTime: 调用的平均时间</li>
 	<li>SampleTIme: 随机取样，最后输出取样结果分布，例如“99%的调用在xxx毫秒以内，99.99%的调用在xxx毫秒以内”</li>
 	<li>SingleShotTime:以上模式都是默认一次 iteration 是 1s，唯有 SingleShotTime 是只运行一次。往往同时把 warmup 次数设为0，用于测试冷启动时的性能。</li>
 	<li>All:执行所有的类型测试</li>
</ul>
<strong>@Measurement(基本测试参数)</strong>
<ul>
 	<li>iterations 进行测试的轮次</li>
 	<li>time 每轮进行的时长</li>
 	<li>timeUnit 时长单位</li>
</ul>
<strong>@Warmup</strong>

基准测试预热选项，有时候在JVM的优化下（比如JIT），前几次测试的结果一般不准确，因此我们可以指定预热时间，将前几次的测试结果丢弃。<code>@Warmup</code>的选项和<code>@Measurement</code>是相同的

<strong>@Threads</strong>

每个进程中的测试线程，根据具体情况选择，一般为cpu乘以2。

<strong>@Fork</strong>

启动测试进程数，比如@Fork(2)，那么JMH会启动两个进程进行测试

<strong>@OutputTimeUnit</strong>

基准测试时间单位，比如秒，毫秒，微秒等

<strong>@Param</strong>

指定参数，可以用来测试在不同参数的情况下方法的运行效率

<strong>@Setup</strong>

方法级注解，被标记的方法会在启动前运行，一般用来在测试之前进行一些准备工作，比如数据初始化等

<strong>@TearDown</strong>

方法级注解，被标记的方法会在测试完成后运行，一般用来在测试之后的一些清理工作，比如关闭连接等

<strong>@State</strong>

当使用@Setup参数的时候，必须在类上加这个参数，不然会提示无法运行。

State 用于声明某个类是一个“状态”，然后接受一个 Scope 参数用来表示该状态的共享范围。 因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。Scope 主要分为三种。
<ul>
 	<li>Thread: 该状态为每个线程独享。</li>
 	<li>Group: 该状态为同一个组里面所有线程共享。</li>
 	<li>Benchmark: 该状态在所有线程间共享。</li>
</ul>
官方文档中，有个比较好的例子来展示@state的使用：<a href="http://hg.openjdk.java.net/code-tools/jmh/file/cb9aa824b55a/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_03_States.java">JMHSample_03_States</a>
<blockquote>在JMH能做的，远不止这些，想要了解更多，可以阅读<a href="https://openjdk.java.net/projects/code-tools/jmh/">官方文档</a></blockquote>
参考文章：

<a href="http://www.importnew.com/12548.html">JMH简介-ImportNew</a>

<a href="https://www.xncoding.com/2018/01/07/java/jmh.html">Java微基准测试框架JMH</a>

<a href="https://openjdk.java.net/projects/code-tools/jmh/">JMH官方文档</a>

[<a href="https://www.hollischuang.com/archives/1072">译]使用JMH进行微基准测试：不要猜，要测试！</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>892</wp:post_id>
		<wp:post_date><![CDATA[2018-11-28 21:43:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-28 13:43:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%8d%e8%a6%81%e7%8c%9c%ef%bc%8c%e8%a6%81%e6%b5%8b%e8%af%95%ef%bc%81-jmh%e4%bb%8b%e7%bb%8d]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="java%e5%b7%a5%e5%85%b7"><![CDATA[Java工具]]></category>
		<category domain="post_tag" nicename="jmh"><![CDATA[JMH]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>个人日记： IDEA 调试快捷键</title>
		<link>http://dengchengchao.com/?p=899</link>
		<pubDate>Thu, 29 Nov 2018 06:10:40 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=899</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>IDEA 调试快捷键速查</h3>
之前一直用VS，习惯了VS的调试模式，刚开始使用IDEA的时候还不习惯。这里记录一下IDEA调试的快捷键
<table style="height: 342px;" width="752">
<thead>
<tr>
<td align="center"><strong>快捷键</strong></th>
<td align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>Ctrl+F8</code></td>
<td align="center">设置/取消现在的断点</td>
</tr>
<tr>
<td align="center"><code>Shift+F7</code></td>
<td align="center">选择进入方法内部，可以跟踪JDK的方法</td>
</tr>
<tr>
<td align="center"><code>Shift+F8</code></td>
<td align="center">跳出方法继续执行</td>
</tr>
<tr>
<td align="center"><code>Shift+F9</code></td>
<td align="center">以Debug模式开始执行方法</td>
</tr>
<tr>
<td align="center"><code>Alt+F8</code></td>
<td align="center">添加表达式进行计算</td>
</tr>
<tr>
<td align="center"><code>Alt+F9</code></td>
<td align="center">运行到光标处</td>
</tr>
<tr>
<td align="center"><code>Alt+F10</code></td>
<td align="center">光标跳转到现在运行的位置</td>
</tr>
<tr>
<td align="center"><code>F7</code></td>
<td align="center">一步一步执行，遇见方法会进入方法</td>
</tr>
<tr>
<td align="center"><code>F8</code></td>
<td align="center">一行一行执行，遇见方法不进入方法</td>
</tr>
<tr>
<td align="center"><code>F9</code></td>
<td align="center">恢复程序正常执行,知道运行到下一个断点</td>
</tr>
</tbody>
</table>
其中最常用的便是：<code>F7</code>,<code>F8</code>,<code>F9</code>,以及<code>Alt+F10</code>和<code>Shift+F8</code>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>899</wp:post_id>
		<wp:post_date><![CDATA[2018-11-29 14:10:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-29 06:10:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%aa%e4%ba%ba%e6%97%a5%e8%ae%b0%ef%bc%9a-idea-%e8%b0%83%e8%af%95%e5%bf%ab%e6%8d%b7%e9%94%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="idea"><![CDATA[IDEA]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="diary"><![CDATA[日记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 干货之深人理解内部类</title>
		<link>http://dengchengchao.com/?p=914</link>
		<pubDate>Wed, 05 Dec 2018 01:42:35 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=914</guid>
		<description></description>
		<content:encoded><![CDATA[可以将一个类定义在另一个类或方法中，这样的类叫做内部类 --《Thinking in Java》

说起内部类，大家并不陌生，并且会经常在实例化容器的时候使用到它。但是内部类的具体细节语法，原理以及实现是什么样的可以不少人都还挺陌生，这里作一篇总结，希望通过这篇总结提高对内部类的认识。

<hr />

<h2>内部类是什么？</h2>
由文章开头可知，内部类的定义为：定义在另一个类或方法中的类。而根据使用场景的不同，内部类还可以分为四种：成员内部类，局部内部类，匿名内部类和静态内部类。每一种的特性和注意事项都不同，下面我们一一说明。
<h4>成员内部类</h4>
顾名思义，成员内部类是定义在类内部，作为类的成员的类。如下：
<pre><code class="language-java ">public class Outer {

   public class Inner{

   }

}

</code></pre>
特点如下：
1. 成员内部类可以被权限修饰符(eg. <code>public,private等</code>)所修饰
2. 成员内部类可以访问外部类的所有成员,（包括<code>private</code>）成员
3. 成员内部类是默认包含了一个指向外部类对象的引用
4. 如同使用<code>this</code>一样，当成员名或方法名发生覆盖时，可以使用外部类的名字加.this指定访问外部类成员。如：<code>Outer.this.name</code>
5. 成员内部类不可以定义<code>static</code>成员
6. 成员内部类创建语法：
<pre><code class="language-java ">Outer outer=new Outer();
Outer.Inner inner=outer.new Inner();
</code></pre>
<h4>局部内部类</h4>
局部内部类是定义在方法或者作用域中类，它和成员内部类的区别仅在于访问权限的不同。
<pre><code class="language-java ">public class Outer{
    public void test(){
        class Inner{

        }
    }
}
</code></pre>
特点如下：
1. 局部内部类不能有访问权限修饰符
2. 局部内部类不能被定义为<code>static</code>
3. 局部内部类不能定义<code>static</code>成员
4. 局部内部类默认包含了外部类对象的引用
5. 局部内部类也可以使用<code>Outer.this</code>语法制定访问外部类成员
6. 局部内部类想要使用方法或域中的变量,该变量必须是<code>final</code>的
<blockquote>在JDK1.8 以后，没有<code>final</code>修饰，<code>effectively final</code>的即可。什么意思呢？就是没有<code>final</code>修饰，但是如果加上<code>final</code>编译器也不会报错即可。</blockquote>
<h4>匿名内部类</h4>
匿名内部类是与继承合并在一起的没有名字的内部类
<pre><code class="language-java ">public class Outer{
    public List list=new ArrayList(){
        {
            add("test");
        }
    };
}
</code></pre>
这是我们平时最常用的语法。
匿名内部类的特点如下：
1. 匿名内部类使用单独的块表示初始化块<code>{}</code>
2. 匿名内部类想要使用方法或域中的变量，该变量必须是<code>final</code>修饰的，JDK1.8之后<code>effectively final</code>也可以
3. 匿名内部类默认包含了外部类对象的引用
4. 匿名内部类表示继承所<strong>依赖</strong>的类
<h4>嵌套类</h4>
嵌套类是用<code>static</code>修饰的成员内部类
<pre><code class="language-java ">public class Outer {

   public static class Inner{

   }

}
</code></pre>
特点如下：
1. 嵌套类是四种类中唯一一个不包含对外部类对象的引用的内部类
2. 嵌套类可以定义<code>static</code>成员
3. 嵌套类能访问外部类任何静态数据成员与方法。
<blockquote>构造函数可以看作静态方法，因此可以访问。</blockquote>

<hr />

<h2>为什么要有内部类？</h2>
从上面可以看出，内部类的特性和类方差不多，但是内部类有许多繁琐的细节语法。既然内部类有这么多的细节要注意，那为什么Java还要支持内部类呢？
<h5>1. 完善多重继承</h5>
<ol>
 	<li>在早期C++作为面向对象编程语言的时候，最难处理的也就是多重继承，多重继承对于代码耦合度，代码使用人员的理解来说，并不怎么友好，并且还要比较出名的死亡菱形的多重继承问题。因此Java并不支持多继承。</li>
 	<li>后来，Java设计者发现，没有多继承，一些代码友好的设计与编程问题变得十分难以解决。于是便产生了内部类。内部类具有：隐式包含外部类对象并且能够与之通信的特点，完美的解决了多重继承的问题。</li>
</ol>
<h5>2. 解决多次实现/继承问题</h5>
<ol>
 	<li>有时候在一个类中，需要多次通过不同的方式实现同一个接口，如果没有内部类，必须多次定义不同数量的类，但是使用内部类可以很好的解决这个问题，每个内部类都可以实现同一个接口，即实现了代码的封装，又实现了同一接口不同的实现。</li>
 	<li>内部类可以将组合的实现封装在内部中。</li>
</ol>

<hr />

<h2>为什么内部类的语法这么繁杂</h2>
这一点是本文的重点。内部类语法之所以这么繁杂，是因为它是新数据类型加语法糖的结合。想要理解内部类，还得从本质上出发.

内部类根据应用场景的不同分为4种。其应用场景完全可以和类方法对比起来。
下面我们通过类方法对比的模式一一解答为什么内部类会有这样的特点
<h4>成员内部类——&gt;成员方法</h4>
成员内部类的设计完全和成员方法一样。
调用成员方法：<code>outer.getName()</code>
新建内部类对象:<code>outer.new Inner()</code>
它们都是要依赖对象而被调用。
正如《Thinking in Java》所说，<code>outer.getName()</code>正真的形似是<code>Outer.getName(outer)</code>,也就是将调用对象作为参数传递给方法。
新建一个内部类也是这样：<code>Outer.new Inner(outer)</code>

下面，我们用实际情况证明：
新建一个包含内部类的类：
<pre><code class="">public class Outer {

    private int m = 1;

    public class Inner {

        private void test() {
            //访问外部类private成员
            System.out.println(m);
        }
    }
}
</code></pre>
编译，会发现会在编译目标目录生成两个.class文件：<code>Outer.class</code>和<code>Outer$Inner.class</code>。
<blockquote>PS:不知道为什么Java总是和$过不去，就连变量命名规则都要比C++多一个能由$组成 ：）</blockquote>
将<code>Outer$Inner.class</code>放入IDEA中打开，会自动反编译，查看结果：
<pre><code class="">public class Outer$Inner {
    public Outer$Inner(Outer this$0) {
        this.this$0 = this$0;
    }

    private void test() {
        System.out.println(Outer.access$000(this.this$0));
    }
}
</code></pre>
可以看见，编译器已经自动生成了一个默认构造器，这个默认构造器是一个带有外部类型引用的参数构造器。

可以看到外部类成员对象的引用：Outer是由<code>final</code>修饰的。

因此：
1. 成员内部类作为类级成员，因此能被访问修饰符所修饰
2. 成员内部类中包含创建内部类时对外部类对象的引用，所以成员内部类能访问外部类的所有成员。
3. 语法规定：因为它作为外部类的一部分成员，所以即使<code>private</code>的对象，内部类也能访问。。通过Outer.access$ 指令访问
4. 如同非静态方法不能访问静态成员一样，非静态内部类也被设计的不能拥有静态变量，因此内部类不能定义<code>static</code>对象和方法。
<blockquote>但是可以定义<code>static final</code>变量，这并不冲突，因为所定义的<code>final</code>字段必须是编译时确定的，而且在编译类时会将对应的变量替换为具体的值，所以在JVM看来，并没有访问内部类。</blockquote>
<h4>局部内部类——&gt; 局部代码块</h4>
局部内部类可以和局部代码块相理解。它最大的特点就是只能访问外部的<code>final</code>变量。
先别着急问为什么。
定义一个局部内部类：
<pre><code class="">public class Outer {

    private void test() {

        int  m= 3;
        class Inner {
            private void print() {
                System.out.println(m);
            }
        }
    }

}
</code></pre>
编译，发现生成两个.class文件<code>Outer.class</code>和<code>Outer$1Inner.class</code>
将<code>Outer$1Inner.class</code>放入IDEA中反编译：
<pre><code class="">class Outer$1Inner {
    Outer$1Inner(Outer this$0, int var2) {
        this.this$0 = this$0;
        this.val$m = var2;
    }

    private void print() {
        System.out.println(this.val$m);
    }
}

</code></pre>
可以看见，编译器自动生成了带有两个参数的默认构造器。
看到这里，也许应该能明了：我们将代码转换下：
<pre><code class="">public class Outer {
    private void test() {
        int  m= 3;
        Inner inner=new Outer$1Inner(this,m);

        inner.print();
        }
    }

}
</code></pre>
也就是在Inner中，其实是将m的值，拷贝到内部类中的。<code>print()</code>方法只是输出了m，如果我们写出了这样的代码：
<pre><code class="">    private void test() {

        int  m= 3;

        class Inner {

            private void print() {
               m=4;
            }
        }

       System.out.println(m);  
    }
</code></pre>
在我们看来,m的值应该被修改为4，但是它真正的效果是：
<pre><code class="">private void test(){
    int m = 3;

    print(m);

    System.out.println(m);
}

private void print(int m){
    m=4;
}
</code></pre>
m被作为参数拷贝进了方法中。因此修改它的值其实没有任何效果，所以为了不让程序员随意修改m而却没达到任何效果而迷惑，m必须被<code>final</code>修饰。

<strong>绕了这么大一圈，为什么编译器要生成这样的效果呢?</strong>
其实，了解闭包的概念的人应该都知道原因。而Java中各种诡异的语法一般都是由生命周期带来的影响。上面的程序中，m是一个局部变量，它被定义在栈上，而<code>new Outer$1Inner(this,m);</code>所生成的对象，是定义在堆上的。如果不将m作为成员变量拷贝进对象中，那么离开m的作用域，<code>Inner</code>对象所指向的便是一个无效的地址。因此，编译器会自动将局部类所使用的所有参数自动生成成员。
<blockquote>为什么其他语言没有这种现象呢？
这又回到了一个经典的问题上：Java是值传递还是引用传递。由于Java <strong>always pass-by-value</strong>，对于真正的引用，Java是无法传递过去的。而上面的问题核心就在与m如果被改变了，那么其它的m的副本是无法感知到的。而其他语言都通过其他的途径解决了这个问题。
<em>对于C++就是一个指针问题</em>。</blockquote>
理解了真正的原因，便也能知道什么时候需要<code>final</code>，什么时候不需要<code>final</code>了。
<pre><code class="">public class Outer {
    private void test() {
        class Inner {
        int m=3;
            private void print() {
                System.out.println(m);//作为参数传递，本身都已经 pass-by-value。不用final
                int c=m+1; //直接使用m，需要加final

            }
        }
    }

}
</code></pre>
而在Java 8 中，已经放宽政策，允许是<code>effectively final</code>的变量，实际上，就是编译器在编译的过程中，帮你加上<code>final</code>而已。而你应该保证允许编译器加上<code>final</code>后，程序不报错。
<ol start="2">
 	<li>局部内部类还有个特点就是不能有权限修饰符。就好像局部变量不能有访问修饰符一样</li>
 	<li>由上面可以看到，外部对象同样是被传入局部类中，因此局部类可以访问外部对象</li>
</ol>
<h4>嵌套类——&gt;静态方法</h4>
嵌套类没什么好说的，就好像静态方法一样，他可以被直接访问，他也能定义静态变量。同时不能访问非静态成员。
值得注意的是《Think in Java》中说过，可以将构造函数看作为静态方法，因此嵌套类可以访问外部类的构造方法。
<h4>匿名类——&gt;局部方法+继承的语法糖</h4>
匿名类可以看作是对前3种类的再次扩展。具体来说匿名类根据应用场景可以看作：
<ul>
 	<li>成员内部类+继承</li>
 	<li>局部内部类+继承</li>
 	<li>嵌套内部类+继承</li>
</ul>
匿名类语法为:
<pre><code class="">new 继承类名(){

  //Override 重载的方法    

}
</code></pre>
返回的结果会向上转型为继承类。

声明一个匿名类：
<pre><code class="">public class Outer {

    private  List list=new ArrayList(){
        {
            add("test");
        }
    };

}
</code></pre>
这便是一个经典的匿名类用法。
同样编译上面代码会看到生成了两个.class文件<code>Outer.class</code>,<code>Outer$1.class</code>
将<code>Outer$1.class</code>放入IDEA中反编译：
<pre><code class="">class Outer$1 extends ArrayList {
    Outer$1(Outer this$0) {
        this.this$0 = this$0;
        this.add("1");
    }
}

</code></pre>
可以看到匿名类的完整语法便是继承+内部类。
由于匿名类可以申明为成员变量，局部变量，静态成员变量，因此它的组合便是几种内部类加继承的语法糖，这里不一一证明。
在这里值得注意的是匿名类由于没有类名，因此不能通过语法糖像正常的类一样声明构造函数，但是编译器可以识别<code>{}</code>,并在编译的时候将代码放入构造函数中。
<blockquote><code>{}</code>可以有多个，会在生成的构造函数中按顺序执行。</blockquote>

<hr />

<h2>怎么正确的使用内部类</h2>
在第二小节中，我们已经讨论过内部类的应用场景，但是如何优雅，并在正确的应用场景使用它呢？本小节将会详细讨论。

1.<strong>注意内存泄露</strong>

《Effective Java》第二十四小节明确提出过。优先使用静态内部类。这是为什么呢？
由上面的分析我们可以知道，除了嵌套类，其他的内部类都隐式包含了外部类对象。这便是Java内存泄露的源头。看代码：

定义Outer：
<pre><code class="language-java ">public class Outer{

    public  List getList(String item) {

        return new ArrayList() {
            {
                add(item);
            }
        };
    }
}
</code></pre>
使用Outer:
<pre><code class="language-java ">public class Test{

   public static List getOutersList(){

    Outer outer=new Outer();
    //do something
    List list=outer.getList("test");

    return list;    
   }
   public static void main(String[] args){
       List list=getOutersList();


      //do something with list
   }

}

</code></pre>
相信这样的代码一定有同学写出来，这涉及到一个习惯的问题：

<strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong>

我们先研究上面的代码，最大的问题便是带来的内存泄露：
在使用过程中，我们定义<code>Outer</code>对象完成一系列的动作
<ul>
 	<li>使用<code>outer</code>得到了一个<code>ArraList</code>对象</li>
 	<li>将<code>ArrayList</code>作为结果返回出去。</li>
</ul>
正常来说，在<code>getOutersList</code>方法中，我们<code>new</code>出来了两个对象：<code>outer</code>和<code>list</code>，而在离开此方法时，我们只将<code>list</code>对象的引用传递出去,<code>outer</code>的引用随着方法栈的退出而被销毁。按道理来说，<code>outer</code>对象此时应该没有作用了，也应该在下一次内存回收中被销毁。

<strong>然而</strong>,事实并不是这样。按上面所说的，新建的<code>list</code>对象是默认包含对<code>outer</code>对象的引用的，因此只要<code>list</code>不被销毁，<code>outer</code>对象将会一直存在，然而我们并不需要<code>outer</code>对象，这便是内存泄露。

<strong>怎么避免这种情况呢？</strong>

很简单：<strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong>
<pre><code class="language-java ">public class Outer{

    public static List getList(String item) {

        return new ArrayList() {
            {
                add(item);
            }
        };
    }
}
</code></pre>
这样定义出来的类便是嵌套类+继承，并不包含对外部类的引用。

2.应用于只实现一个接口的实现类
<ul>
 	<li>优雅工厂方法模式</li>
</ul>
我们可以看到，在工厂方法模式中，每个实现都会需要实现一个Fractory来实现产生对象的接口，而这样接口其实和原本的类关联性很大的，因此我们可以将Fractory定义在具体的类中，作为内部类存在
<ul>
 	<li>简单的实现接口</li>
</ul>
<pre><code class="language-java ">       new Thread(new Runnable() {
           @Override
           public void run() {
               System.out.println("test");
           }
       }

       ).start();
    }
</code></pre>
<blockquote>尽量不要直接使用Thread，这里只做演示使用
Java 8 的话建议使用lambda代替此类应用</blockquote>
<ul>
 	<li>同时实现多个接口</li>
</ul>
<pre><code class="language-java ">public class imple{

    public static Eat getDogEat(){
        return new EatDog();
    }

    public static Eat getCatEat(){
        return new EatCat();
    }

    private static class EatDog implements Eat {
        @Override
        public void eat() {
            System.out.println("dog eat");
        }
    }
    private static class EatCat implements Eat{
        @Override
        public void eat() {
            System.out.println("cat eat");
        }
    }
}
</code></pre>
3.<strong>优雅的单例类</strong>
<pre><code class="language-java ">public class Imple {

    public static Imple getInstance(){
        return ImpleHolder.INSTANCE;
    }


    private static class ImpleHolder{
        private static final Imple INSTANCE=new Imple();
    }
}
</code></pre>
4.反序列化JSON接受的JavaBean
有时候需要反序列化嵌套JSON
<pre><code class="language-java ">{
    "student":{
        "name":"",
        "age":""
    }
}
</code></pre>
类似这种。我们可以直接定义嵌套类进行反序列化
<pre><code class="language-java ">public JsonStr{

    private Student student;

    public static Student{
        private String name;
        private String age;

        //getter &amp; setter
    }

    //getter &amp; setter
}

</code></pre>
但是注意，这里应该使用嵌套类，因为我们不需要和外部类进行数据交换。

核心思想：
<ul>
 	<li>嵌套类能够访问外部类的构造函数</li>
 	<li>将第一次访问内部类放在方法中，这样只有调用这个方法的时候才会第一次访问内部类，实现了懒加载</li>
</ul>
内部类还有很多用法，这里不一一列举。

<hr />

<h2>总结</h2>
内部类的理解可以按照方法来理解，但是内部类很多特性都必须剥开语法糖和明白为什么需要这么做才能完全理解，明白内部类的所有特性才能更好使用内部类，在内部类的使用过程中，一定记住：能使用嵌套类就使用嵌套类，如果内部类需要和外部类联系，才使用内部类。最后<strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong>可以防止内部类内存泄露。
<blockquote>尊重劳动成果，转载请标注出处。</blockquote>
参考文章：
<a href="https://www.zhihu.com/question/21373020">Java 中引入内部类的意义？</a>
<a href="https://bbs.csdn.net/topics/390607261">成员内部类里面为什么不能有静态成员和方法？</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>914</wp:post_id>
		<wp:post_date><![CDATA[2018-12-05 09:42:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-05 01:42:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-%e5%b9%b2%e8%b4%a7%e4%b9%8b%e6%b7%b1%e5%ba%a6%e7%90%86%e8%a7%a3%e5%86%85%e9%83%a8%e7%b1%bb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="java-%e5%9f%ba%e7%a1%80"><![CDATA[Java 基础]]></category>
		<category domain="post_tag" nicename="java-%e5%b9%b2%e8%b4%a7"><![CDATA[Java 干货]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 干货之深入理解泛型</title>
		<link>http://dengchengchao.com/?p=916</link>
		<pubDate>Wed, 05 Dec 2018 01:43:39 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=916</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>一般的类和方法，只能使用具体的类型，要么是基本类型，要么是自定义的类。如果要编写可以应用多中类型的代码，这种刻板的限制对代码得束缚会就会很大。
---《Thinking in Java》</blockquote>
泛型大家都接触的不少，但是由于Java 历史的原因，Java 中的泛型一直被称为<em>伪泛型</em>,因此对Java中的泛型，有很多不注意就会遇到的“坑”,在这里详细讨论一下。对于基础而又常见的语法，这里就直接略过了。
<h3>什么是泛型</h3>
自JDK 1.5 之后，Java 通过泛型解决了容器类型安全这一问题，而几乎所有人接触泛型也是通过Java的容器。那么泛型究竟是什么？
<strong>泛型的本质是参数化类型</strong>
也就是说，泛型就是将所操作的数据类型作为参数的一种语法。
<pre><code>public class Paly&lt;T&gt;{
    T play(){}
}
</code></pre>
其中<code>T</code>就是作为一个类型参数在<code>Play</code>被实例化的时候所传递来的参数，比如：
<pre><code>Play&lt;Integer&gt; playInteger=new Play&lt;&gt;();
</code></pre>
这里<code>T</code>就会被实例化为<code>Integer</code>
<h3>泛型的作用</h3>
<h5>- 使用泛型能写出更加灵活通用的代码</h5>
泛型的设计主要参照了C++的模板，旨在能让人写出更加通用化，更加灵活的代码。模板/泛型代码，就好像做雕塑时的模板，有了模板，需要生产的时候就只管向里面注入具体的材料就行，不同的材料可以产生不同的效果，这便是泛型最初的设计宗旨。
<h5>- 泛型将代码安全性检查提前到编译期</h5>
泛型被加入Java语法中，还有一个最大的原因：解决容器的类型安全，使用泛型后，能让编译器在编译的时候借助传入的类型参数检查对容器的插入，获取操作是否合法，从而将<strong>运行时</strong><code>ClassCastException</code>转移到<strong>编译时</strong>比如：
<pre><code>List dogs =new ArrayList();
dogs.add(new Cat());
</code></pre>
在没有泛型之前，这种代码除非运行，否则你永远找不到它的错误。但是加入泛型后
<pre><code>List&lt;Dog&gt; dogs=new ArrayList&lt;&gt;();
dogs.add(new Cat());//Error Compile
</code></pre>
会在编译的时候就检查出来。
<h5>- 泛型能够省去类型强制转换</h5>
在JDK1.5之前，Java容器都是通过将类型向上转型为<code>Object</code>类型来实现的，因此在从容器中取出来的时候需要手动的强制转换。
<pre><code>Dog dog=(Dog)dogs.get(1);
</code></pre>
加入泛型后，由于编译器知道了具体的类型，因此编译期会自动进行强制转换，使得代码更加优雅。
<h3>泛型的具体实现</h3>
我们可以定义泛型类，泛型方法，泛型接口等，那泛型的底层是怎么实现的呢？
<h4>从历史上看泛型</h4>
由于泛型是JDK1.5之后才出现的，在此之前需要使用泛型(模板代码)的地方都是通过<code>Object</code>向上转型以及强制类型转换实现的,这样虽然能满足大多数需求，但是有个最大的问题就在于类型安全。在获取“真正”的数据的时候，如果不小心强制转换成了错误类型，这种错误只能在真正运行的时候才能发现。

因此Java 1.5推出了“泛型”，也就是在原本的基础上加上了编译时类型检查的语法糖。Java 的泛型推出来后，引起来很多人的吐槽，因为相对于C++等其他语言的泛型，Java的泛型代码的灵活性依然会受到很多限制。这是因为Java被规定必须<strong>保持二进制向后兼容性</strong>，也就是一个在Java 1.4版本中可以正常运行的Class文件，放在Java 1.5中必须是能够正常运行的:

在1.5之前，这种类型的代码是没有问题的。
<pre><code>public static void addRawList(List list){
   list.add("123");
   list.add(2);
}
</code></pre>
1.5之后泛型大量应用后：
<pre><code>public static void addGenericList(List&lt;String&gt; list){
    list.add("1");//Only String
    list.add("2");
}
</code></pre>
虽然我们认为<code>addRawList()</code>方法中的代码不是类型安全的，但是某些时候这种代码是有用的，在设计JDK1.5的时候，想要实现泛型有两种选择：
<ul>
 	<li>需要泛型化的类型（主要是容器（Collections）类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型；</li>
 	<li>直接把已有的类型泛型化，让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</li>
</ul>
什么意思呢？也就是第一种办法是在原有的Java库的基础上，再添加一些库，这些库的功能和原本的一模一样，只是这些库是使用Java新语法泛型实现的，而第二种办法是保持和原本的库的高度一致性，不添加任何新的库。

在出现了泛型之后，原本没有使用泛型的代码就被称为<code>raw type</code>(原始类型)
Java 的二进制向后兼容性使得Java 需要实现前后兼容的泛型，也就是说以前使用原始类型的代码可以继续被泛型使用，现在的泛型也可以作为参数传递给原始类型的代码。
比如
<pre><code> List&lt;String&gt; list=new ArrayList&lt;&gt;();
 List rawList=new ArrayList();
 addRawList(list);
 addGenericList(list);

 addRawList(rawList);
 addGenericList(rawList);
</code></pre>
上面的代码能够正确的运行。

Java 设计者选择了第二种方案
<blockquote>C# 在1.1过渡到2.0中增加泛型时，使用了第一种方案。</blockquote>

<hr />

为了实现以上功能，Java 设计者将泛型完全作为了<strong>语法糖</strong>加入了新的语法中，什么意思呢？也就是说泛型对于JVM来说是透明的，有泛型的和没有泛型的代码，通过编译器编译后所生成的二进制代码是完全相同的。

这个语法糖的实现被称为<strong>擦除</strong>
<h4>擦除的过程</h4>
<strong>泛型</strong>是为了将具体的类型作为参数传递给方法，类，接口。
<strong>擦除</strong>是在代码运行过程中将具体的类型都抹除。

前面说过，Java 1.5 之前需要编写模板代码的地方都是通过<code>Object</code>来保存具体的值。比如：
<pre><code>public class Node{
   private Object obj;

   public Object get(){
       return obj;
   }

   public void set(Object obj){
       this.obj=obj;
   }

   public static void main(String[] argv){

    Student stu=new Student();
    Node  node=new Node();
    node.set(stu);
    Student stu2=(Student)node.get();
   }
}


</code></pre>
这样的实现能满足绝大多数需求，但是泛型还是有更多方便的地方，最大的一点就是编译期类型检查，于是Java 1.5之后加入了泛型，但是这个泛型仅仅是在编译的时候帮你做了编译时类型检查，成功编译后所生成的<code>.class</code>文件还是一模一样的，这便是擦除

1.5 以后实现
<pre><code>public class Node&lt;T&gt;{

    private T obj;

    public T get(){

        return obj;
    }

    public void set(T obj){
        this.obj=obj;
    }

    public static void main(String[] argv){

    Student stu=new Student();
    Node&lt;Student&gt;  node=new Node&lt;&gt;();
    node.set(stu);
    Student stu2=node.get();
  }
}
</code></pre>
两个版本生成的.class文件：
Node:
<pre><code>  public Node();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return
  public java.lang.Object get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn
  public void set(java.lang.Object);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return
}

</code></pre>
Node&lt; T&gt;
<pre><code>public class Node&lt;T&gt; {
  public Node();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return
  public T get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn

  public void set(T);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return
}

</code></pre>
可以看到泛型就是在使用泛型代码的时候，将<strong>类型信息</strong>传递给具体的泛型代码。而经过编译后，生成的<code>.class</code>文件和原始的代码一模一样，就好像传递过来的<strong>类型信息</strong>又被擦除了一样。
<h4>泛型语法</h4>
Java 的泛型就是一个<strong>语法糖</strong>，而语法糖最大的好处就是让人方便使用，但是它的缺点也在于如果不剥开这颗语法糖，有很多奇怪的语法就很难理解。
<ul>
 	<li><strong>类型边界</strong>
前面说过，泛型在最终会擦除为<code>Object</code>类型。这样导致的是在编写泛型代码的时候，对泛型元素的操作只能使用<code>Object</code>自带的一些方法，但是有时候我们想使用其他类型的方法呢？
比如：</li>
</ul>
<pre><code>public class Node{
    private People obj;
    public People get(){

        return obj;
    }

    public void set(People obj){
        this.obj=obj;
    }

    public void playName(){
        System.out.println(obj.getName());
    }
}
</code></pre>
如上，代码中需要使用<code>obj.getName()</code>方法，因此比如规定传入的元素必须是<code>People</code>及其子类，那么这样的方法怎么通过泛型体现出来呢？
答案是<code>extend</code>，泛型重载了<code>extend</code>关键字，可以通过<code>extend</code>关键字指定最终擦除所替代的类型。
<pre><code>public class Node&lt;T extend People&gt;{

    private T obj;

    public T get(){

        return obj;
    }

    public void set(T obj){
        this.obj=obj;
    }

    public void playName(){
        System.out.println(obj.getName());
    }
}
</code></pre>
通过<code>extend</code>关键字，编译器会将最后类型都擦除为<code>People</code>类型，就好像最开始我们看见的原始代码一样。
<h4>泛型与向上转型的概念</h4>
先讲一讲几个概念：
<ul>
 	<li>协变：子类能向父类转换 <code>Animal a1=new Cat();</code></li>
 	<li>逆变: 父类能向子类转换 <code>Cat a2=(Cat)a1;</code></li>
 	<li>不变: 两者均不能转变</li>
</ul>
对于协变，我们见得最多的就是多态,而逆变常见于强制类型转换。
这好像没什么奇怪的。但是看以下代码：
<pre><code>public static void error(){
   Object[] nums=new Integer[3];
   nums[0]=3.2;
   nums[1]="string"; //运行时报错，nums运行时类型是Integer[]
   nums[2]='2';
 }
</code></pre>
因为数组是协变的，因此<code>Integer[]</code>可以转换为<code>Object[]</code>，在编译阶段编译器只知道<code>nums</code>是<code>Object[]</code>类型，而运行时<code>nums</code>则为<code>Integer[]</code>类型，因此上述代码能够编译，但是运行会报错。

这就是常见的人们所说的数组是协变的。这里带来一个问题，为什么数组要设计为协变的呢？既然不让运行，那么通过编译有什么用？

答案是在泛型还没出现之前，数组协变能够解决一些通用的问题：
<pre><code>public static void sort(Object[] a) {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a);
        else
            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
    }

</code></pre>
<pre><code>/**
 * 摘自JDK 1.8 Arrays.equals()
 */
  public static boolean equals(Object[] a, Object[] a2) {
        //...
        for (int i=0; i&lt;length; i++) {
            Object o1 = a[i];
            Object o2 = a2[i];
            if (!(o1==null ? o2==null : o1.equals(o2)))
                return false;
        }
        //..
        return true;
    }

</code></pre>
可以看到，<strong>只操作数组本身，而不关心数组中具体保存的元素</strong>，或者是不管什么元素，取出来就作为一个<code>Object</code>存储的时候，只用编写一个<code>Object[]</code>就能写出通用的数组参数方法。比如：
<pre><code>Arrays.sort(new Student[]{...})
Arrays.sort(new Apple[]{...})
</code></pre>
等，但是这样的设计留下来的诟病就是偶尔会出现对<strong>数组元素有具体的操作</strong>的代码，比如上面的<code>error()</code>方法。

<strong>泛型</strong>的出现，是为了保证类型安全的问题，如果将泛型也设计为协变的话，那也就违背了泛型最初设计的初衷，因此在Java中，泛型是不变的，什么意思呢？
<blockquote><code>List&lt;Number&gt;</code> 和 <code>List&lt;Integer&gt;</code> 是没有任何关系的，即使<code>Integer</code> 是 <code>Number</code>的子类</blockquote>
也就是对于
<pre><code>public static void test(List&lt; Number&gt; nums){...}
</code></pre>
方法，是无法传递一个<code>List&lt;Integer&gt;</code>参数的

逆变一般常见于强制类型转换。
<pre><code>Object obj="test";
String str=(String)obj;
</code></pre>
原理便是Java 反射机制能够记住变量<code>obj</code>的实际类型，在强制类型转换的时候发现<code>obj</code>实际上是一个<code>String</code>类型，于是就正常的通过了运行。
<h4>泛型与向上转型的实现</h4>
前面说了这么多，应该关心的问题在于，如何解决既能使用数组协变带来的方便性，又能得到泛型不变带来的类型安全？

答案依然是<code>extend</code>,<code>super</code>关键字与通配符<code>?</code>

泛型重载了<code>extend</code>，<code>super</code>关键字来解决通用泛型的表示。
<blockquote>注意：这句话可能比较熟悉，没错，前面说过<code>extend</code>还被用来指定擦除到的具体类型，比如<code>&lt;E extend Fruit&gt;</code>，表示在运行时将<code>E</code>替换为<code>Fruit</code>,注意<code>E</code>表示的是一个具体的类型，但是这里的<code>extend</code>和通配符连续使用<code>&lt;? extend Fruit&gt;</code>这里通配符<code>?</code>表示一个通用类型，它所表示的泛型在编译的时候，被指定的具体的类型必须是<code>Fruit</code>的子类。比如<code>List&lt;? extend Fruit&gt; list= new ArrayList&lt;Apple&gt;</code>，<code>ArrayList&lt;&gt;</code>中指定的类型必须是<code>Apple</code>,<code>Orange</code>等。不要混淆。</blockquote>
概念麻烦，直接看代码：

<strong>协变泛型</strong>
<pre><code>
public static  void playFruit(List &lt; ? extends Fruit&gt; list){
    //do somthing
}

public static void main(String[] args) {
    List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
    List&lt;Orange&gt; oranges=new ArrayList&lt;&gt;();
    List&lt;Food&gt; foods =new ArrayList&lt;&gt;();
    playFruit(apples);
    playFruit(oranges);
    //playFruit(foods); 编译错误
}

</code></pre>
可以看到,参数<code>List &lt; ? extend Fruit&gt;</code>所表示是需要一个<code>List&lt;&gt;</code>，其中尖括号所指定的具体类型必须是继承自<code>Fruit</code>的。

这样便解决了泛型无法<strong>向上转型</strong>的问题,前面说过，数组也能向上转型，但是存取元素有问题啊，这里继续深入，看看泛型是怎么解决这一问题的。
<pre><code>  public static  void playFruit(List &lt; ? extends  Fruit&gt; list){
         list.add(new Apple());
    }
</code></pre>
向传入的<code>list</code>添加元素，你会发现编译器直接会报错

<strong>逆变泛型</strong>
<pre><code>public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
     //..
}

public static void main(String[] args) {
    List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
    List&lt;Food&gt; foods =new ArrayList&lt;&gt;();
    List&lt;Object&gt; objects=new ArrayList&lt;&gt;();
    playFruitBase(foods);
    playFruitBase(objects);
    //playFruitBase(apples); 编译错误
}

</code></pre>
同理，参数<code>List &lt; ? super Fruit&gt;</code>所表示是需要一个<code>List&lt;&gt;</code>,其中尖括号所指定的具体类型必须是<code>Fruit</code>的父类类型。
<pre><code>public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
    Object obj=list.get(0);
}
</code></pre>
取出<code>list</code>的元素，你会发现编译器直接会报错

<strong>思考：</strong> 为什么要这么麻烦要区分开到底是xxx的父类还是子类，不能直接使用一个关键字表示么？

前面说过，数组的协变之所以会有问题是因为在对数组中的元素进行存取的时候出现的问题，只要不对数组元素进行操作，就不会有什么问题，因此可以使用通配符<code>?</code>达到此效果：
<pre><code>public static void playEveryList(List &lt; ?&gt; list){
    //..
}
</code></pre>
对于<code>playEveryList</code>方法，传递任何类型的<code>List</code>都没有问题，但是你会发现对于<code>list</code>参数，你无法对里面的元素存和取。这样便达到了上面所说的<strong>安全类型的协变数组</strong>的效果。

但是觉得多数时候，我们还是希望对元素进行操作的，这就是<code>extend</code>和<code>super</code>的功能。

<strong><code>&lt;? extend Fruit&gt;</code></strong>表示传入的泛型具体类型必须是继承自<code>Fruit</code>，那么我们可以里面的元素一定能向上转型为<code>Fruit</code>。但是也仅仅能确定里面的元素一定能向上转型为<code>Fruit</code>
<pre><code>public static  void playFruit(List &lt; ? extends  Fruit&gt; list){
     Fruit fruit=list.get(0);
     //list.add(new Apple());
}
</code></pre>
比如上面这段代码，可以正确的取出元素，因为我们知道所传入的参数一定是继承自<code>Fruit</code>的，比如
<pre><code>List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
List&lt;Orange&gt; oranges=new ArrayList&lt;&gt;();
</code></pre>
都能正确的转换为<code>Fruit</code>，
<strong>但是</strong>我们并不知道里面的元素具体是什么，有可能是<code>Orange</code>，也有可能是<code>Apple</code>，因此，在<code>list.add()</code>的时候，就会出现问题，有可能将<code>Apple</code>放入了<code>Orange</code>里面，因此，为了不出错，编译器会禁止向里面加入任何元素。这也就解释了协变中使用<code>add</code>会出错的原因。

<hr />

同理：

<strong><code>&lt;? super Fruit&gt;</code></strong>表示传入的泛型具体类型必须是<code>Fruit</code>的<strong>父类</strong>，那么我们可以确定只要元素是<code>Fruit</code>以及能转型为<code>Fruit</code>的，一定能向上转型为对应的此类型,比如：
<pre><code>    public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
        list.add(new Apple());
    }
</code></pre>
因为<code>Apple</code>继承自<code>Fruit</code>，而参数list最终被指定的类型一定是<code>Fruit</code>的父类，那么<code>Apple</code>一定能向上转型为对应的<strong>父类</strong>，因此可以向里面存元素。

但是我们只能确定他是<code>Furit</code>的父类，并不知道具体的“上限”。因此无法将取出来的元素统一的类型(当然可以用<code>Object</code>)。比如
<pre><code>List&lt;Eatables&gt; eatables=new ArrayList&lt;&gt;();
List&lt;Food&gt; foods=new ArrayList&lt;&gt;();
</code></pre>
除了
<pre><code>Object obj;

obj=eatables.get(0);
obj=foods.get(0);
</code></pre>
之外，没有确定类型可以修饰<code>obj</code>以达到类似的效果。

针对上述情况。我们可以总结为：<strong>PECS</strong>原则，<code>Producer-Extend,Customer-Super</code>，也就是泛型代码是生产者，使用<code>Extend</code>，泛型代码作为消费者<code>Super</code>
<h3>泛型的阴暗角落</h3>
通过擦除而实现的泛型，有些时候会有很多让人难以理解的规则，但是了解了泛型的真正实现又会觉得这样做还是比较合情合理。下面分析一下关于泛型在应用中有哪些奇怪的现象：
<h4>擦除的地点---边界</h4>
<pre><code>    static &lt;T&gt; T[] toArray(T... args) {

        return args;
    }

    static &lt;T&gt; T[] pickTwo(T a, T b, T c) {
        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(a, b);
            case 1: return toArray(a, c);
            case 2: return toArray(b, c);
        }
        throw new AssertionError(); // Can't get here
    }

    public static void main(String[] args) {

        String[] attributes = pickTwo("Good", "Fast", "Cheap");
    }
</code></pre>
这是在《Effective Java》中看到的例子，编译此代码没有问题，但是运行的时候却会类型转换错误：<code>Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;</code>

当时对泛型并没有一个很好的认识，一直不明白为什么会有<code>Object[]</code>转换到<code>String[]</code>的错误。现在我们来分析一下：
<ul>
 	<li>首先看<code>toArray</code>方法，由本章最开始所说泛型使用擦除实现的原因是为了保持有泛型和没有泛型所产生的代码一致，那么：</li>
</ul>
<pre><code>    static &lt;T&gt; T[] toArray(T... args) {
        return args;
    }
</code></pre>
和
<pre><code>static Object[] toArray(Object... args){
    return args;
}
</code></pre>
生成的二进制文件是一致的。

进而剥开可变数组的语法糖：
<pre><code>static Object[] toArray(Object[] args){
    return args;
}
</code></pre>
<pre><code>    static &lt;T&gt; T[] pickTwo(T a, T b, T c) {

        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(a, b);
            case 1: return toArray(a, c);
            case 2: return toArray(b, c);
        }

        throw new AssertionError(); // Can't get here
    }
</code></pre>
和
<pre><code>    static  Object[] pickTwo(Object a, Object b, Object c) {
        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(new Object[]{a,b});//可变参数会根据调用类型转换为对应的数组，这里a,b,c都是Object
            case 1: return toArray(new Object[]{a,b});
            case 2: return toArray(new Object[]{a,b});
        }

        throw new AssertionError(); // Can't get here
    }
</code></pre>
是一致的。
那么调用<code>pickTwo</code>方法实际编译器会帮我进行类型转换
<pre><code>    public static void main(String[] args) {
        String[] attributes =(String[])pickTwo("Good", "Fast", "Cheap");
    }
</code></pre>
可以看到，问题就在于可变参数那里，使用可变参数编译器会自动把我们的参数包装为一个数组传递给对应的方法，而这个数组的包装在泛型中，会最终翻译为<code>new Object</code>，那么<code>toArray</code>接受的实际类型是一个<code>Object[]</code>，当然不能强制转换为<code>String[]</code>

上面代码出错的关键点就在于泛型经过擦除后，类型变为了<code>Object</code>导致可变参数直接包装出了一个<code>Object</code>数组产生的类型转换失败。
<h4>基类劫持</h4>
<pre><code>public interface Playable&lt;T&gt;  {
    T play();
}

public class Base implements  Playable&lt;Integer&gt; {
    @Override
    public Integer play() {
        return 4;
    }
}

public class Derived extend Base implements Playable&lt;String&gt;{
    ...
}
</code></pre>
可以发现在定义<code>Derived</code>类的时候编译器会报错。
观察<code>Derived</code>的定义可以看到，它继承自<code>Base</code>
那么它就拥有一个<code>Integer play()</code>和方法，继而实现了<code>Playable&lt;String&gt;</code>接口，也就是它必须实现一个<code>String play()</code>方法。对于<code>Integer play()</code>和<code>String play()</code>两个方法的函数签名相同，但是返回类型不同，这样的方法在Java 中是不允许共存的：
<pre><code>public static void main(String[] args){
    new Derived().play();
}
</code></pre>
编译器并不知道应该调用哪一个<code>play()</code>方法。
<h4>自限定类型</h4>
自限定类型简单点说就是将泛型的类型限制为自己以及自己的子类。最常见的在于实现<code>Compareable</code>接口的时候：
<pre><code>public class Student implements Comparable&lt;Student&gt;{

}
</code></pre>
这样就成功的限制了能与<code>Student</code>相比较的类型只能是<code>Student</code>，这很好理解。

但是正如Java 中返回类型是协变的：
<pre><code>public class father{
    public Number test(){
        return nll;
    }
}


public class Son extend father{
    @Override
    public Interger test(){
        return null;
    }
}
</code></pre>
有些时候对于一些专门用来被继承的类需要<strong>参数</strong>也是协变的。比如实现一个<code>Enum</code>:
<pre><code>public abstract class Enum implements Comparable&lt;Enum&gt;,Serializable{
    @Override
    public int compareTo(Enum o) {
        return 0;
    }
}
</code></pre>
这样是没有问题的，但是正如常规所说，假如<code>Pen</code>和<code>Cup</code>都继承于<code>Enum</code>，但是按道理来说笔和杯子之间相互比较是没有意义的,也就是说在<code>Enum</code>中<code>compareTo(Enum o)</code>方法中的<code>Enum</code>这个限定词太宽泛，这个时候有两种思路：
1. 子类分别自己实现<code>Comparable</code>接口，这样就可以规定更详细的参数类型，但是由于前面所说，会出现基类劫持的问题
2. 修改父类的代码，让父类不实现<code>Comparable</code>接口，让每个子类自己实现即可，但是这样会有大量<strong>一模一样</strong>的代码，只是传入的参数类型不同而已。

而更好的解决方案便是使用泛型的自限定类型：
<pre><code>public abstract class Enum&lt;E extend Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;,Serializable{
    @Override
    public int compareTo(E o) {
        return 0;
    }

}
</code></pre>
泛型的自限定类型比起传统的自限定类型有个更大的优点就是它能使泛型的参数也变成协变的。

这样每个子类只用在集成的时候指定类型
<pre><code>public class Pen extends Enum&lt;Pen&gt;{}
public class Cup extends Cup&lt;Cup&gt;{}
</code></pre>
便能够在定义的时候指定想要与那种类型进行比较，这样达到的效果便相当于每个子类都分别自己实现了一个自定义的<code>Comparable</code>接口。

自限定类型一般用在继承体系中，需要参数协变的时候。
<blockquote>尊重原创，转载请注明出处</blockquote>
参考文章：
<a href="https://www.zhihu.com/question/28665443/answer/118148143">Java不能实现真正泛型的原因？ - RednaxelaFX的回答 - 知乎</a>
<a href="https://blog.csdn.net/u011240877/article/details/53545041">深入理解 Java 泛型</a>
<a href="https://www.zhihu.com/question/21394322/answer/121073103">java中，数组为什么要设计为协变？ - 胖君的回答 - 知乎</a>
<a href="https://ask.csdn.net/questions/678250">java泛型中的自限定类型有什么作用-CSDN问答</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>916</wp:post_id>
		<wp:post_date><![CDATA[2018-12-05 09:43:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-05 01:43:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-%e5%b9%b2%e8%b4%a7%e4%b9%8b%e6%b7%b1%e5%ba%a6%e7%90%86%e8%a7%a3%e6%b3%9b%e5%9e%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="java-%e5%9f%ba%e7%a1%80"><![CDATA[Java 基础]]></category>
		<category domain="post_tag" nicename="java-%e5%b9%b2%e8%b4%a7"><![CDATA[Java 干货]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>你真的懂堆和栈吗？</title>
		<link>http://dengchengchao.com/?p=922</link>
		<pubDate>Thu, 06 Dec 2018 06:40:46 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=922</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>堆与栈</h3>

关于堆和栈的问题，对于熟悉C++的同学来说可能理解的比较清楚，但是由于Java的一切对象都是在堆上，因此有时候可能反而会比较迷惑，比如：

<blockquote>
  为什么要分堆和栈？
  
  堆和栈的区别是什么？
  
  为什么堆是线程共享的而栈不是？
</blockquote>

很多懂一点Java的人甚至是懂一点编程的人都知道内存一般分为堆和栈，栈由系统进行关系，而堆由程序员自己管理，...balabala，基本任何一本语言基础书都会提到这些特点，但是你有想过为什么吗？

<h3>为什么要分堆和栈</h3>

之所以要区分堆和栈，是由于程序需要两种不同特性的内存形似而确定的。在C++中，新建一个对象有两种方式，<strong>静态分配</strong>和<strong>动态分配</strong>，

<strong>静态分配</strong>

一般来说，静态分配用于初始化已知对象大小的时候，比如<code>int a[10];</code>如果我们能够确定这个数组是10个，我们可以使用这种方式。这种方式所需要的内存在<strong>编译期间</strong>即可确定，因此操作系统便可以<strong>预先确定</strong>所指定大小内存给变量，并且可以在变量生命周期结束后自动释放。

<strong>动态分配</strong>

然而在某些场景下，可能需要根据某些情况来申请内存，比如<code>int*  a =new int[count];</code>而变量<code>count</code>可能就来自于某个配置文件或者用户手动输入的值。这个时候操作系统就无法再<strong>预先确定</strong>内存大小，并且不执行到<code>new int[count]</code>这一行代码的时候，是无法知道所要分配的内存大小，因此操作系统分出一块内存，用来进行动态分配。并且规定，动态分配的内存需要由客户端自行管理。

<strong>Java 中的堆</strong>

由于JVM规范中规定，JVM中的一切对象都存储在堆上(内存逃逸除外)。因此在Java中并不存在对象的静态分配，因此堆和栈的来源看似就非常理所当然。但是要明白，在操作系统中，堆和栈的出现的缘由。

<h3>堆和栈的区别</h3>

知道了为什么要区分堆和栈，再来看看堆和栈的区别。

<ul>
<li>堆是运行时确定内存大小，而栈在编译时即可确定内存大小

理由便是第一节中提到的，这是区分堆和栈的初衷</p></li>
<li><p>堆内存由用户管理(Java中由JVM管理)，栈内存会被自动释放</p></li>
<li><p>栈实现方式采用数据结构中的栈实现，具有(LIFO)的顺序特点，堆为一块一块的内存</p></li>
<li><p>栈由于其实现方式，在分配速度上比堆快的多。分配一块栈内存不过是简单的移动一个指针</p></li>
<li><p>在JVM中，栈不会被程序员直接使用，程序员操作的一般都是堆。</p></li>
<li><p>栈为线程私有而堆为线程共享</p></li>
</ul>

<p>虽然堆和栈有这么多的区别，但是这些区别都是由于操作系统而决定的，在硬件上，他们本质都是<code>RAM</code>

<h3>为什么堆是线程共享的而栈不是？</h3>

上面最后一点提到了栈为线程私有而堆为线程共享。这是为什么呢？？？

其实很简单，为了解决一个问题：线程间通信。

想要实现线程间通信，目前有两种方法：

<ul>
<li>消息传递</li>
<li>共享内存</li>
</ul>

<strong>共享内存</strong>便是我们所说的将堆设置为线程间共享的，这样我们能够通过堆中的对象实现数据共享，这样便使得其他线程能够知道某个线程修改了某个数据。但是这样带来的问题可能就有线程安全问题等，但是这样做的优势便在于<strong>速度更快</strong>和<strong>节约内存</strong>，Java，C#等使用这种方式

<strong>消息传递</strong>是每个线程都私有自己的数据空间，当需要线程通信的时候，便需要一个线程显示的给另外一个线程发送具体的消息，这样做的能够让多线程更加安全，但是私有的线程空间和消息传递带来的是需要给内个线程都拷贝相同的对象，变量等，并且可能会带来效率问题。而Erlang和JoCaml便是使用消息传递式线程通信。

<blockquote>
  尊重劳动成功，转载注明原创
</blockquote>

参考文章：

<a href="https://stackoverflow.com/questions/3318750/why-do-threads-share-the-heap-space">Why do threads share the heap space?</a>

<a href="https://www.programmerinterview.com/index.php/data-structures/difference-between-stack-and-heap/">What’s the difference between a stack and a heap?</a>

<a href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">What and where are the stack and heap?</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>922</wp:post_id>
		<wp:post_date><![CDATA[2018-12-06 14:40:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-06 06:40:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%a0%e7%9c%9f%e7%9a%84%e6%87%82%e5%a0%86%e5%92%8c%e6%a0%88%e5%90%97%ef%bc%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="java-%e5%9f%ba%e7%a1%80"><![CDATA[Java 基础]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>设计模式读书笔记：绪</title>
		<link>http://dengchengchao.com/?p=925</link>
		<pubDate>Sat, 08 Dec 2018 09:14:36 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=925</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>绪：</h3>

大体看了一下《大话设计模式》和《Head First 设计模式》先写写感想，然后以此为开篇写读书笔记。

<h3>为什么要有设计模式？</h3>

其实，最主要的原因便是，对于软件来说，<strong>需求是会一直变化</strong>的,扩展功能，增加逻辑等，都会导致我们再次编辑原本写好的代码。但是只要有点编程经验的人都会知道，哪怕是自己写的代码，过一段时间，依然会想不起来或者看不懂具体的逻辑是什么，这样导致问题便是要是修改原本的代码，可能会因为和原本的逻辑不通而导致原本正常运行的功能出现异常。

于是人们提出，应该<strong>面向扩展，关闭修改</strong>，什么意思呢？也就是说如果写的代码可扩展，那么在下次出现修改扩展/添加功能的时候，就<strong>不用修改</strong>以前的代码，<strong>只用增加</strong>新的逻辑即可。

这便是设计模式的核心：<strong>开闭原则(OCP)</strong>:Open Closed Principle

其实开闭原则在生活中也能找到，比如《大话设计模式》里面提到的曹操作诗的故事，正是活字印刷术达到了灵活，可扩展，因此才被评为中国四大发明之一。

<h3>设计模式有什么用？</h3>

既然<strong>开闭原则</strong>这么重要，那么怎么才能遵循开闭原则呢？前人通过无数的经验教训总结了其他许多的原则<strong>用来达到开闭原则</strong>，最重要的便是<strong>SOILD</strong>原则

<strong>S</strong>：SRP(Single Responsibility Principle)，单一职责原则，只有遵循单一职责原则，才能在需要扩展功能，修改功能的时候不影响其他的类。

<strong>O:</strong>OCP(Open Closed Principle)，开闭原则，作为面向对象设计中可复用的基石，是面向对象设计中最重要的原则之一。

<strong>I:</strong>ISP(interface-segregation principles),接口隔离原则，此原则的主要目的是使系统低耦合，从而让系统更容易重构，修改等。

<strong>L:</strong>LSP(Liskov Substitution principle),里斯替换原则，实现开闭原则的基础

<strong>D:</strong>DIP(Dependency inversion principle),依赖倒转原则，同样主要目的使系统解耦，遵循此原则可以使系统更加灵活，更加容易重构。

还有其他两个比较常提的有：

最少知道原则，又叫迪米特原则，该原则同样是降低系统的耦合性，使得系统的间的逻辑更加简单

组合优于继承原则，该原则主要降低系统的耦合性，使得某个类被修改的时候，不会影响到其他的类

可以看出来，开闭原则是主要目的，而里斯替换原则是实现开闭原则的基础，其他原则主要目的就是降低系统的耦合性，使得系统更加灵活。

<strong>使用设计模式来遵循设计原则</strong>

说了这么多，那设计模式和这些原则有什么关联呢？

可以看到，上面的原则说起来比较容易，但是在实际的开发中，你会发现如果结合各种业务逻辑，你会发现难以遵守各种原则，而设计模式便是前人总结出来用于各个情况下，应该如何设计才能遵守各个原则的一种框架。

比如在平时的代码中，我们可能会写一堆if-else来判断各种情况下应该执行的代码。但是随着系统越来越庞大，逻辑越来越复杂，在扩展时可能稍微不注意就改了其他原本正确的代码，这个时候我们就可以使用<strong>责任链模式</strong>或者<strong>状态模式</strong>重构这段代码，使得系统在扩展的时候不会影响到其他的代码。

<strong>设计模式---框架代名词</strong>

设计模式还有个好处就在于使用模式能够成为一种设计方式的代名词，比如在重构/编写代码的时候，我们可能会觉得这里使用责任链模式比较好，因此我们会按照传统的责任链模式重构系统，这样当另外一个学过设计模式的人看到这个代码的时候，只用看个大概就能瞬间明白整个流程。就好像我们把使用面粉和上发酵粉加水烘烤半个小时所产生的食物叫做面包一样，一提到面包，你就能想到它的样子。

<h3>正确使用设计模式</h3>

在《大话设计模式》和《Head First 设计模式》两本书中，都提到了<strong>过度设计</strong>这个词。设计模式也是有的副作用的，大多设计模式为了在修改时不修改其他代码，都是通过里斯替换原则来面向接口设计一个功能，这样带来的问题就是系统中类过多。设计模式的副作用还有其他的，因此如果我们在编写代码得时候，如果能够预测需求的变化，可以预先进行简单的设计，如果无法预测未来变化，可以等需要重构的时候在使用设计模式。

但是在编写代码的时候，可以尽量遵循设计原则，即使不使用设计模式，代码的灵活性依然会很高。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>925</wp:post_id>
		<wp:post_date><![CDATA[2018-12-08 17:14:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-08 09:14:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%ef%bc%9a%e7%bb%aa]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式]]></category>
		<category domain="post_tag" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 技术干货之内部类</title>
		<link>http://dengchengchao.com/?p=764</link>
		<pubDate>Wed, 07 Nov 2018 03:19:49 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=764</guid>
		<description></description>
		<content:encoded><![CDATA[可以将一个类定义在另一个类或方法中，这样的类叫做内部类 --《Thinking in Java》

说起内部类，大家并不陌生，并且会经常在实例化容器的时候使用到它。但是内部类的具体细节语法，原理以及实现是什么样的可以不少人都还挺陌生，这里作一篇总结，希望通过这篇总结提高对内部类的认识。

<hr />

<h2>内部类是什么？</h2>

由文章开头可知，内部类的定义为：定义在另一个类或方法中的类。而根据使用场景的不同，内部类还可以分为四种：成员内部类，局部内部类，匿名内部类和静态内部类。每一种的特性和注意事项都不同，下面我们一一说明。

<h4>成员内部类</h4>

顾名思义，成员内部类是定义在类内部，作为类的成员的类。如下：

<pre><code class="language-java ">public class Outer {

   public class Inner{

   }

}

</code></pre>

特点如下：
1. 成员内部类可以被权限修饰符(eg. <code>public,private等</code>)所修饰
2. 成员内部类可以访问外部类的所有成员,（包括<code>private</code>）成员
3. 成员内部类是默认包含了一个指向外部类对象的引用
4. 如同使用<code>this</code>一样，当成员名或方法名发生覆盖时，可以使用外部类的名字加.this指定访问外部类成员。如：<code>Outer.this.name</code>
5. 成员内部类不可以定义<code>static</code>成员
6. 成员内部类创建语法：

<pre><code class="language-java ">Outer outer=new Outer();
Outer.Inner inner=outer.new Inner();
</code></pre>

<h4>局部内部类</h4>

局部内部类是定义在方法或者作用域中类，它和成员内部类的区别仅在于访问权限的不同。

<pre><code class="language-java ">public class Outer{
    public void test(){
        class Inner{

        }
    }
}
</code></pre>

特点如下：
1. 局部内部类不能有访问权限修饰符
2. 局部内部类不能被定义为<code>static</code>
3. 局部内部类不能定义<code>static</code>成员
4. 局部内部类默认包含了外部类对象的引用
5. 局部内部类也可以使用<code>Outer.this</code>语法制定访问外部类成员
6. 局部内部类想要使用方法或域中的变量,该变量必须是<code>final</code>的

<blockquote>在JDK1.8 以后，没有<code>final</code>修饰，<code>effectively final</code>的即可。什么意思呢？就是没有<code>final</code>修饰，但是如果加上<code>final</code>编译器也不会报错即可。</blockquote>

<h4>匿名内部类</h4>

匿名内部类是与继承合并在一起的没有名字的内部类

<pre><code class="language-java ">public class Outer{
    public List list=new ArrayList(){
        {
            add("test");
        }
    };
}
</code></pre>

这是我们平时最常用的语法。
匿名内部类的特点如下：
1. 匿名内部类使用单独的块表示初始化块<code>{}</code>
2. 匿名内部类想要使用方法或域中的变量，该变量必须是<code>final</code>修饰的，JDK1.8之后<code>effectively final</code>也可以
3. 匿名内部类默认包含了外部类对象的引用
4. 匿名内部类表示继承所<strong>依赖</strong>的类

<h4>嵌套类</h4>

嵌套类是用<code>static</code>修饰的成员内部类

<pre><code class="language-java ">public class Outer {

   public static class Inner{

   }

}
</code></pre>

特点如下：
1. 嵌套类是四种类中唯一一个不包含对外部类对象的引用的内部类
2. 嵌套类可以定义<code>static</code>成员
3. 嵌套类能访问外部类任何静态数据成员与方法。

<blockquote>构造函数可以看作静态方法，因此可以访问。</blockquote>

<hr />

<h2>为什么要有内部类？</h2>

从上面可以看出，内部类的特性和类方差不多，但是内部类有许多繁琐的细节语法。既然内部类有这么多的细节要注意，那为什么Java还要支持内部类呢？

<h5>1. 完善多重继承</h5>

<ol>
    <li>在早期C++作为面向对象编程语言的时候，最难处理的也就是多重继承，多重继承对于代码耦合度，代码使用人员的理解来说，并不怎么友好，并且还要比较出名的死亡菱形的多重继承问题。因此Java并不支持多继承。</li>
    <li>后来，Java设计者发现，没有多继承，一些代码友好的设计与编程问题变得十分难以解决。于是便产生了内部类。内部类具有：隐式包含外部类对象并且能够与之通信的特点，完美的解决了多重继承的问题。</li>
</ol>

<h5>2. 解决多次实现/继承问题</h5>

<ol>
    <li>有时候在一个类中，需要多次通过不同的方式实现同一个接口，如果没有内部类，必须多次定义不同数量的类，但是使用内部类可以很好的解决这个问题，每个内部类都可以实现同一个接口，即实现了代码的封装，又实现了同一接口不同的实现。</li>
    <li>内部类可以将组合的实现封装在内部中。</li>
</ol>

<hr />

<h2>为什么内部类的语法这么繁杂</h2>

这一点是本文的重点。内部类语法之所以这么繁杂，是因为它是新数据类型加语法糖的结合。想要理解内部类，还得从本质上出发.

内部类根据应用场景的不同分为4种。其应用场景完全可以和类方法对比起来。
下面我们通过类方法对比的模式一一解答为什么内部类会有这样的特点

<h4>成员内部类——&gt;成员方法</h4>

成员内部类的设计完全和成员方法一样。
调用成员方法：<code>outer.getName()</code>
新建内部类对象:<code>outer.new Inner()</code>
它们都是要依赖对象而被调用。
正如《Thinking in Java》所说，<code>outer.getName()</code>正真的形似是<code>Outer.getName(outer)</code>,也就是将调用对象作为参数传递给方法。
新建一个内部类也是这样：<code>Outer.new Inner(outer)</code>

下面，我们用实际情况证明：
新建一个包含内部类的类：

<pre><code class="">public class Outer {

    private int m = 1;

    public class Inner {

        private void test() {
            //访问外部类private成员
            System.out.println(m);
        }
    }
}
</code></pre>

编译，会发现会在编译目标目录生成两个.class文件：<code>Outer.class</code>和<code>Outer$Inner.class</code>。

<blockquote>PS:不知道为什么Java总是和$过不去，就连变量命名规则都要比C++多一个能由$组成 ：）</blockquote>

将<code>Outer$Inner.class</code>放入IDEA中打开，会自动反编译，查看结果：

<pre><code class="">public class Outer$Inner {
    public Outer$Inner(Outer this$0) {
        this.this$0 = this$0;
    }

    private void test() {
        System.out.println(Outer.access$000(this.this$0));
    }
}
</code></pre>

可以看见，编译器已经自动生成了一个默认构造器，这个默认构造器是一个带有外部类型引用的参数构造器。

可以看到外部类成员对象的引用：Outer是由<code>final</code>修饰的。

因此：
1. 成员内部类作为类级成员，因此能被访问修饰符所修饰
2. 成员内部类中包含创建内部类时对外部类对象的引用，所以成员内部类能访问外部类的所有成员。
3. 语法规定：因为它作为外部类的一部分成员，所以即使<code>private</code>的对象，内部类也能访问。。通过Outer.access$ 指令访问
4. 如同非静态方法不能访问静态成员一样，非静态内部类也被设计的不能拥有静态变量，因此内部类不能定义<code>static</code>对象和方法。

<blockquote>但是可以定义<code>static final</code>变量，这并不冲突，因为所定义的<code>final</code>字段必须是编译时确定的，而且在编译类时会将对应的变量替换为具体的值，所以在JVM看来，并没有访问内部类。</blockquote>

<h4>局部内部类——&gt; 局部代码块</h4>

局部内部类可以和局部代码块相理解。它最大的特点就是只能访问外部的<code>final</code>变量。
先别着急问为什么。
定义一个局部内部类：

<pre><code class="">public class Outer {

    private void test() {

        int  m= 3;
        class Inner {
            private void print() {
                System.out.println(m);
            }
        }
    }

}
</code></pre>

编译，发现生成两个.class文件<code>Outer.class</code>和<code>Outer$1Inner.class</code>
将<code>Outer$1Inner.class</code>放入IDEA中反编译：

<pre><code class="">class Outer$1Inner {
    Outer$1Inner(Outer this$0, int var2) {
        this.this$0 = this$0;
        this.val$m = var2;
    }

    private void print() {
        System.out.println(this.val$m);
    }
}

</code></pre>

可以看见，编译器自动生成了带有两个参数的默认构造器。
看到这里，也许应该能明了：我们将代码转换下：

<pre><code class="">public class Outer {
    private void test() {
        int  m= 3;
        Inner inner=new Outer$1Inner(this,m);

        inner.print();
        }
    }

}
</code></pre>

也就是在Inner中，其实是将m的值，拷贝到内部类中的。<code>print()</code>方法只是输出了m，如果我们写出了这样的代码：

<pre><code class="">    private void test() {

        int  m= 3;

        class Inner {

            private void print() {
               m=4;
            }
        }

       System.out.println(m);  
    }
</code></pre>

在我们看来,m的值应该被修改为4，但是它真正的效果是：

<pre><code class="">private void test(){
    int m = 3;

    print(m);

    System.out.println(m);
}

private void print(int m){
    m=4;
}
</code></pre>

m被作为参数拷贝进了方法中。因此修改它的值其实没有任何效果，所以为了不让程序员随意修改m而却没达到任何效果而迷惑，m必须被<code>final</code>修饰。

<strong>绕了这么大一圈，为什么编译器要生成这样的效果呢?</strong>
其实，了解闭包的概念的人应该都知道原因。而Java中各种诡异的语法一般都是由生命周期带来的影响。上面的程序中，m是一个局部变量，它被定义在栈上，而<code>new Outer$1Inner(this,m);</code>所生成的对象，是定义在堆上的。如果不将m作为成员变量拷贝进对象中，那么离开m的作用域，<code>Inner</code>对象所指向的便是一个无效的地址。因此，编译器会自动将局部类所使用的所有参数自动生成成员。

<blockquote>为什么其他语言没有这种现象呢？
这又回到了一个经典的问题上：Java是值传递还是引用传递。由于Java <strong>always pass-by-value</strong>，对于真正的引用，Java是无法传递过去的。而上面的问题核心就在与m如果被改变了，那么其它的m的副本是无法感知到的。而其他语言都通过其他的途径解决了这个问题。
<em>对于C++就是一个指针问题</em>。</blockquote>

理解了真正的原因，便也能知道什么时候需要<code>final</code>，什么时候不需要<code>final</code>了。

<pre><code class="">public class Outer {
    private void test() {
        class Inner {
        int m=3;
            private void print() {
                System.out.println(m);//作为参数传递，本身都已经 pass-by-value。不用final
                int c=m+1; //直接使用m，需要加final

            }
        }
    }

}
</code></pre>

而在Java 8 中，已经放宽政策，允许是<code>effectively final</code>的变量，实际上，就是编译器在编译的过程中，帮你加上<code>final</code>而已。而你应该保证允许编译器加上<code>final</code>后，程序不报错。

<ol start="2">
    <li>局部内部类还有个特点就是不能有权限修饰符。就好像局部变量不能有访问修饰符一样</li>
    <li>由上面可以看到，外部对象同样是被传入局部类中，因此局部类可以访问外部对象</li>
</ol>

<h4>嵌套类——&gt;静态方法</h4>

嵌套类没什么好说的，就好像静态方法一样，他可以被直接访问，他也能定义静态变量。同时不能访问非静态成员。
值得注意的是《Think in Java》中说过，可以将构造函数看作为静态方法，因此嵌套类可以访问外部类的构造方法。

<h4>匿名类——&gt;局部方法+继承的语法糖</h4>

匿名类可以看作是对前3种类的再次扩展。具体来说匿名类根据应用场景可以看作：

<ul>
    <li>成员内部类+继承</li>
    <li>局部内部类+继承</li>
    <li>嵌套内部类+继承</li>
</ul>

匿名类语法为:

<pre><code class="">new 继承类名(){

  //Override 重载的方法    

}
</code></pre>

返回的结果会向上转型为继承类。

声明一个匿名类：

<pre><code class="">public class Outer {

    private  List list=new ArrayList(){
        {
            add("test");
        }
    };

}
</code></pre>

这便是一个经典的匿名类用法。
同样编译上面代码会看到生成了两个.class文件<code>Outer.class</code>,<code>Outer$1.class</code>
将<code>Outer$1.class</code>放入IDEA中反编译：

<pre><code class="">class Outer$1 extends ArrayList {
    Outer$1(Outer this$0) {
        this.this$0 = this$0;
        this.add("1");
    }
}

</code></pre>

可以看到匿名类的完整语法便是继承+内部类。
由于匿名类可以申明为成员变量，局部变量，静态成员变量，因此它的组合便是几种内部类加继承的语法糖，这里不一一证明。
在这里值得注意的是匿名类由于没有类名，因此不能通过语法糖像正常的类一样声明构造函数，但是编译器可以识别<code>{}</code>,并在编译的时候将代码放入构造函数中。

<blockquote><code>{}</code>可以有多个，会在生成的构造函数中按顺序执行。</blockquote>

<hr />

<h2>怎么正确的使用内部类</h2>

在第二小节中，我们已经讨论过内部类的应用场景，但是如何优雅，并在正确的应用场景使用它呢？本小节将会详细讨论。

1.<strong>注意内存泄露</strong>

《Effective Java》第二十四小节明确提出过。优先使用静态内部类。这是为什么呢？
由上面的分析我们可以知道，除了嵌套类，其他的内部类都隐式包含了外部类对象。这便是Java内存泄露的源头。看代码：

定义Outer：

<pre><code class="language-java ">public class Outer{

    public  List getList(String item) {

        return new ArrayList() {
            {
                add(item);
            }
        };
    }
}
</code></pre>

使用Outer:

<pre><code class="language-java ">public class Test{

   public static List getOutersList(){

    Outer outer=new Outer();
    //do something
    List list=outer.getList("test");

    return list;    
   }
   public static void main(String[] args){
       List list=getOutersList();


      //do something with list
   }

}

</code></pre>

相信这样的代码一定有同学写出来，这涉及到一个习惯的问题：

<strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong>

我们先研究上面的代码，最大的问题便是带来的内存泄露：
在使用过程中，我们定义<code>Outer</code>对象完成一系列的动作

<ul>
    <li>使用<code>outer</code>得到了一个<code>ArraList</code>对象</li>
    <li>将<code>ArrayList</code>作为结果返回出去。</li>
</ul>

正常来说，在<code>getOutersList</code>方法中，我们<code>new</code>出来了两个对象：<code>outer</code>和<code>list</code>，而在离开此方法时，我们只将<code>list</code>对象的引用传递出去,<code>outer</code>的引用随着方法栈的退出而被销毁。按道理来说，<code>outer</code>对象此时应该没有作用了，也应该在下一次内存回收中被销毁。

<strong>然而</strong>,事实并不是这样。按上面所说的，新建的<code>list</code>对象是默认包含对<code>outer</code>对象的引用的，因此只要<code>list</code>不被销毁，<code>outer</code>对象将会一直存在，然而我们并不需要<code>outer</code>对象，这便是内存泄露。

<strong>怎么避免这种情况呢？</strong>

很简单：<strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong>

<pre><code class="language-java ">public class Outer{

    public static List getList(String item) {

        return new ArrayList() {
            {
                add(item);
            }
        };
    }
}
</code></pre>

这样定义出来的类便是嵌套类+继承，并不包含对外部类的引用。

2.应用于只实现一个接口的实现类

<ul>
    <li>优雅工厂方法模式</li>
</ul>

我们可以看到，在工厂方法模式中，每个实现都会需要实现一个Fractory来实现产生对象的接口，而这样接口其实和原本的类关联性很大的，因此我们可以将Fractory定义在具体的类中，作为内部类存在

<ul>
    <li>简单的实现接口</li>
</ul>

<pre><code class="language-java ">       new Thread(new Runnable() {
           @Override
           public void run() {
               System.out.println("test");
           }
       }

       ).start();
    }
</code></pre>

<blockquote>尽量不要直接使用Thread，这里只做演示使用
Java 8 的话建议使用lambda代替此类应用</blockquote>

<ul>
    <li>同时实现多个接口</li>
</ul>

<pre><code class="language-java ">public class imple{

    public static Eat getDogEat(){
        return new EatDog();
    }

    public static Eat getCatEat(){
        return new EatCat();
    }

    private static class EatDog implements Eat {
        @Override
        public void eat() {
            System.out.println("dog eat");
        }
    }
    private static class EatCat implements Eat{
        @Override
        public void eat() {
            System.out.println("cat eat");
        }
    }
}
</code></pre>

3.<strong>优雅的单例类</strong>

<pre><code class="language-java ">public class Imple {

    public static Imple getInstance(){
        return ImpleHolder.INSTANCE;
    }


    private static class ImpleHolder{
        private static final Imple INSTANCE=new Imple();
    }
}
</code></pre>

4.反序列化JSON接受的JavaBean
有时候需要反序列化嵌套JSON

<pre><code class="language-java ">{
    "student":{
        "name":"",
        "age":""
    }
}
</code></pre>

类似这种。我们可以直接定义嵌套类进行反序列化

<pre><code class="language-java ">public JsonStr{

    private Student student;

    public static Student{
        private String name;
        private String age;

        //getter &amp; setter
    }

    //getter &amp; setter
}

</code></pre>

但是注意，这里应该使用嵌套类，因为我们不需要和外部类进行数据交换。

核心思想：

<ul>
    <li>嵌套类能够访问外部类的构造函数</li>
    <li>将第一次访问内部类放在方法中，这样只有调用这个方法的时候才会第一次访问内部类，实现了懒加载</li>
</ul>

内部类还有很多用法，这里不一一列举。

<hr />

<h2>总结</h2>

内部类的理解可以按照方法来理解，但是内部类很多特性都必须剥开语法糖和明白为什么需要这么做才能完全理解，明白内部类的所有特性才能更好使用内部类，在内部类的使用过程中，一定记住：能使用嵌套类就使用嵌套类，如果内部类需要和外部类联系，才使用内部类。最后<strong>不涉及到类成员方法和成员变量的方法，最好定义为static</strong>可以防止内部类内存泄露。

<blockquote>尊重劳动成果，转载请标注出处。</blockquote>

参考文章：
<a href="https://www.zhihu.com/question/21373020">Java 中引入内部类的意义？</a>
<a href="https://bbs.csdn.net/topics/390607261">成员内部类里面为什么不能有静态成员和方法？</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>764</wp:post_id>
		<wp:post_date><![CDATA[2018-11-07 11:19:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-07 03:19:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-%e6%8a%80%e6%9c%af%e6%8f%90%e5%8d%87%e8%87%b3-%e5%86%85%e9%83%a8%e7%b1%bb__trashed]]></wp:post_name>
		<wp:status><![CDATA[trash]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="java"><![CDATA[Java]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="post_tag" nicename="%e5%86%85%e9%83%a8%e7%b1%bb"><![CDATA[内部类]]></category>
		<category domain="post_tag" nicename="%e6%8a%80%e6%9c%af%e5%b9%b2%e8%b4%a7"><![CDATA[技术干货]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[java-%e6%8a%80%e6%9c%af%e6%8f%90%e5%8d%87%e8%87%b3-%e5%86%85%e9%83%a8%e7%b1%bb__trashed]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[14]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[dotGood]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
			<wp:meta_value><![CDATA[publish]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
			<wp:meta_value><![CDATA[1543974226]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_desired_post_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[java-%e6%8a%80%e6%9c%af%e6%8f%90%e5%8d%87%e8%87%b3-%e5%86%85%e9%83%a8%e7%b1%bb]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 技术干货之泛型</title>
		<link>http://dengchengchao.com/?p=767</link>
		<pubDate>Wed, 07 Nov 2018 03:21:34 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=767</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>一般的类和方法，只能使用具体的类型，要么是基本类型，要么是自定义的类。如果要编写可以应用多中类型的代码，这种刻板的限制对代码得束缚会就会很大。
---《Thinking in Java》</blockquote>

泛型大家都接触的不少，但是由于Java 历史的原因，Java 中的泛型一直被称为<em>伪泛型</em>,因此对Java中的泛型，有很多不注意就会遇到的“坑”,在这里详细讨论一下。对于基础而又常见的语法，这里就直接略过了。

<h3>什么是泛型</h3>

自JDK 1.5 之后，Java 通过泛型解决了容器类型安全这一问题，而几乎所有人接触泛型也是通过Java的容器。那么泛型究竟是什么？
<strong>泛型的本质是参数化类型</strong>
也就是说，泛型就是将所操作的数据类型作为参数的一种语法。

<pre><code>public class Paly&lt;T&gt;{
    T play(){}
}
</code></pre>

其中<code>T</code>就是作为一个类型参数在<code>Play</code>被实例化的时候所传递来的参数，比如：

<pre><code>Play&lt;Integer&gt; playInteger=new Play&lt;&gt;();
</code></pre>

这里<code>T</code>就会被实例化为<code>Integer</code>

<h3>泛型的作用</h3>

<h5>- 使用泛型能写出更加灵活通用的代码</h5>

泛型的设计主要参照了C++的模板，旨在能让人写出更加通用化，更加灵活的代码。模板/泛型代码，就好像做雕塑时的模板，有了模板，需要生产的时候就只管向里面注入具体的材料就行，不同的材料可以产生不同的效果，这便是泛型最初的设计宗旨。

<h5>- 泛型将代码安全性检查提前到编译期</h5>

泛型被加入Java语法中，还有一个最大的原因：解决容器的类型安全，使用泛型后，能让编译器在编译的时候借助传入的类型参数检查对容器的插入，获取操作是否合法，从而将<strong>运行时</strong><code>ClassCastException</code>转移到<strong>编译时</strong>比如：

<pre><code>List dogs =new ArrayList();
dogs.add(new Cat());
</code></pre>

在没有泛型之前，这种代码除非运行，否则你永远找不到它的错误。但是加入泛型后

<pre><code>List&lt;Dog&gt; dogs=new ArrayList&lt;&gt;();
dogs.add(new Cat());//Error Compile
</code></pre>

会在编译的时候就检查出来。

<h5>- 泛型能够省去类型强制转换</h5>

在JDK1.5之前，Java容器都是通过将类型向上转型为<code>Object</code>类型来实现的，因此在从容器中取出来的时候需要手动的强制转换。

<pre><code>Dog dog=(Dog)dogs.get(1);
</code></pre>

加入泛型后，由于编译器知道了具体的类型，因此编译期会自动进行强制转换，使得代码更加优雅。

<h3>泛型的具体实现</h3>

我们可以定义泛型类，泛型方法，泛型接口等，那泛型的底层是怎么实现的呢？

<h4>从历史上看泛型</h4>

由于泛型是JDK1.5之后才出现的，在此之前需要使用泛型(模板代码)的地方都是通过<code>Object</code>向上转型以及强制类型转换实现的,这样虽然能满足大多数需求，但是有个最大的问题就在于类型安全。在获取“真正”的数据的时候，如果不小心强制转换成了错误类型，这种错误只能在真正运行的时候才能发现。

因此Java 1.5推出了“泛型”，也就是在原本的基础上加上了编译时类型检查的语法糖。Java 的泛型推出来后，引起来很多人的吐槽，因为相对于C++等其他语言的泛型，Java的泛型代码的灵活性依然会受到很多限制。这是因为Java被规定必须<strong>保持二进制向后兼容性</strong>，也就是一个在Java 1.4版本中可以正常运行的Class文件，放在Java 1.5中必须是能够正常运行的:

在1.5之前，这种类型的代码是没有问题的。

<pre><code>public static void addRawList(List list){
   list.add("123");
   list.add(2);
}
</code></pre>

1.5之后泛型大量应用后：

<pre><code>public static void addGenericList(List&lt;String&gt; list){
    list.add("1");//Only String
    list.add("2");
}
</code></pre>

虽然我们认为<code>addRawList()</code>方法中的代码不是类型安全的，但是某些时候这种代码是有用的，在设计JDK1.5的时候，想要实现泛型有两种选择：

<ul>
    <li>需要泛型化的类型（主要是容器（Collections）类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型；</li>
    <li>直接把已有的类型泛型化，让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</li>
</ul>

什么意思呢？也就是第一种办法是在原有的Java库的基础上，再添加一些库，这些库的功能和原本的一模一样，只是这些库是使用Java新语法泛型实现的，而第二种办法是保持和原本的库的高度一致性，不添加任何新的库。

在出现了泛型之后，原本没有使用泛型的代码就被称为<code>raw type</code>(原始类型)
Java 的二进制向后兼容性使得Java 需要实现前后兼容的泛型，也就是说以前使用原始类型的代码可以继续被泛型使用，现在的泛型也可以作为参数传递给原始类型的代码。
比如

<pre><code> List&lt;String&gt; list=new ArrayList&lt;&gt;();
 List rawList=new ArrayList();
 addRawList(list);
 addGenericList(list);

 addRawList(rawList);
 addGenericList(rawList);
</code></pre>

上面的代码能够正确的运行。

Java 设计者选择了第二种方案

<blockquote>C# 在1.1过渡到2.0中增加泛型时，使用了第一种方案。</blockquote>

<hr />

为了实现以上功能，Java 设计者将泛型完全作为了<strong>语法糖</strong>加入了新的语法中，什么意思呢？也就是说泛型对于JVM来说是透明的，有泛型的和没有泛型的代码，通过编译器编译后所生成的二进制代码是完全相同的。

这个语法糖的实现被称为<strong>擦除</strong>

<h4>擦除的过程</h4>

<strong>泛型</strong>是为了将具体的类型作为参数传递给方法，类，接口。
<strong>擦除</strong>是在代码运行过程中将具体的类型都抹除。

前面说过，Java 1.5 之前需要编写模板代码的地方都是通过<code>Object</code>来保存具体的值。比如：

<pre><code>public class Node{
   private Object obj;

   public Object get(){
       return obj;
   }

   public void set(Object obj){
       this.obj=obj;
   }

   public static void main(String[] argv){

    Student stu=new Student();
    Node  node=new Node();
    node.set(stu);
    Student stu2=(Student)node.get();
   }
}


</code></pre>

这样的实现能满足绝大多数需求，但是泛型还是有更多方便的地方，最大的一点就是编译期类型检查，于是Java 1.5之后加入了泛型，但是这个泛型仅仅是在编译的时候帮你做了编译时类型检查，成功编译后所生成的<code>.class</code>文件还是一模一样的，这便是擦除

1.5 以后实现

<pre><code>public class Node&lt;T&gt;{

    private T obj;

    public T get(){

        return obj;
    }

    public void set(T obj){
        this.obj=obj;
    }

    public static void main(String[] argv){

    Student stu=new Student();
    Node&lt;Student&gt;  node=new Node&lt;&gt;();
    node.set(stu);
    Student stu2=node.get();
  }
}
</code></pre>

两个版本生成的.class文件：
Node:

<pre><code>  public Node();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return
  public java.lang.Object get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn
  public void set(java.lang.Object);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return
}

</code></pre>

Node&lt; T&gt;

<pre><code>public class Node&lt;T&gt; {
  public Node();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return
  public T get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn

  public void set(T);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return
}

</code></pre>

可以看到泛型就是在使用泛型代码的时候，将<strong>类型信息</strong>传递给具体的泛型代码。而经过编译后，生成的<code>.class</code>文件和原始的代码一模一样，就好像传递过来的<strong>类型信息</strong>又被擦除了一样。

<h4>泛型语法</h4>

Java 的泛型就是一个<strong>语法糖</strong>，而语法糖最大的好处就是让人方便使用，但是它的缺点也在于如果不剥开这颗语法糖，有很多奇怪的语法就很难理解。

<ul>
    <li><strong>类型边界</strong>
前面说过，泛型在最终会擦除为<code>Object</code>类型。这样导致的是在编写泛型代码的时候，对泛型元素的操作只能使用<code>Object</code>自带的一些方法，但是有时候我们想使用其他类型的方法呢？
比如：</li>
</ul>

<pre><code>public class Node{
    private People obj;
    public People get(){

        return obj;
    }

    public void set(People obj){
        this.obj=obj;
    }

    public void playName(){
        System.out.println(obj.getName());
    }
}
</code></pre>

如上，代码中需要使用<code>obj.getName()</code>方法，因此比如规定传入的元素必须是<code>People</code>及其子类，那么这样的方法怎么通过泛型体现出来呢？
答案是<code>extend</code>，泛型重载了<code>extend</code>关键字，可以通过<code>extend</code>关键字指定最终擦除所替代的类型。

<pre><code>public class Node&lt;T extend People&gt;{

    private T obj;

    public T get(){

        return obj;
    }

    public void set(T obj){
        this.obj=obj;
    }

    public void playName(){
        System.out.println(obj.getName());
    }
}
</code></pre>

通过<code>extend</code>关键字，编译器会将最后类型都擦除为<code>People</code>类型，就好像最开始我们看见的原始代码一样。

<h4>泛型与向上转型的概念</h4>

先讲一讲几个概念：

<ul>
    <li>协变：子类能向父类转换 <code>Animal a1=new Cat();</code></li>
    <li>逆变: 父类能向子类转换 <code>Cat a2=(Cat)a1;</code></li>
    <li>不变: 两者均不能转变</li>
</ul>

对于协变，我们见得最多的就是多态,而逆变常见于强制类型转换。
这好像没什么奇怪的。但是看以下代码：

<pre><code>public static void error(){
   Object[] nums=new Integer[3];
   nums[0]=3.2;
   nums[1]="string"; //运行时报错，nums运行时类型是Integer[]
   nums[2]='2';
 }
</code></pre>

因为数组是协变的，因此<code>Integer[]</code>可以转换为<code>Object[]</code>，在编译阶段编译器只知道<code>nums</code>是<code>Object[]</code>类型，而运行时<code>nums</code>则为<code>Integer[]</code>类型，因此上述代码能够编译，但是运行会报错。

这就是常见的人们所说的数组是协变的。这里带来一个问题，为什么数组要设计为协变的呢？既然不让运行，那么通过编译有什么用？

答案是在泛型还没出现之前，数组协变能够解决一些通用的问题：

<pre><code>public static void sort(Object[] a) {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a);
        else
            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
    }

</code></pre>

<pre><code>/**
 * 摘自JDK 1.8 Arrays.equals()
 */
  public static boolean equals(Object[] a, Object[] a2) {
        //...
        for (int i=0; i&lt;length; i++) {
            Object o1 = a[i];
            Object o2 = a2[i];
            if (!(o1==null ? o2==null : o1.equals(o2)))
                return false;
        }
        //..
        return true;
    }

</code></pre>

可以看到，<strong>只操作数组本身，而不关心数组中具体保存的元素</strong>，或者是不管什么元素，取出来就作为一个<code>Object</code>存储的时候，只用编写一个<code>Object[]</code>就能写出通用的数组参数方法。比如：

<pre><code>Arrays.sort(new Student[]{...})
Arrays.sort(new Apple[]{...})
</code></pre>

等，但是这样的设计留下来的诟病就是偶尔会出现对<strong>数组元素有具体的操作</strong>的代码，比如上面的<code>error()</code>方法。

<strong>泛型</strong>的出现，是为了保证类型安全的问题，如果将泛型也设计为协变的话，那也就违背了泛型最初设计的初衷，因此在Java中，泛型是不变的，什么意思呢？

<blockquote><code>List&lt;Number&gt;</code> 和 <code>List&lt;Integer&gt;</code> 是没有任何关系的，即使<code>Integer</code> 是 <code>Number</code>的子类</blockquote>

也就是对于

<pre><code>public static void test(List&lt; Number&gt; nums){...}
</code></pre>

方法，是无法传递一个<code>List&lt;Integer&gt;</code>参数的

逆变一般常见于强制类型转换。

<pre><code>Object obj="test";
String str=(String)obj;
</code></pre>

原理便是Java 反射机制能够记住变量<code>obj</code>的实际类型，在强制类型转换的时候发现<code>obj</code>实际上是一个<code>String</code>类型，于是就正常的通过了运行。

<h4>泛型与向上转型的实现</h4>

前面说了这么多，应该关心的问题在于，如何解决既能使用数组协变带来的方便性，又能得到泛型不变带来的类型安全？

答案依然是<code>extend</code>,<code>super</code>关键字与通配符<code>?</code>

泛型重载了<code>extend</code>，<code>super</code>关键字来解决通用泛型的表示。

<blockquote>注意：这句话可能比较熟悉，没错，前面说过<code>extend</code>还被用来指定擦除到的具体类型，比如<code>&lt;E extend Fruit&gt;</code>，表示在运行时将<code>E</code>替换为<code>Fruit</code>,注意<code>E</code>表示的是一个具体的类型，但是这里的<code>extend</code>和通配符连续使用<code>&lt;? extend Fruit&gt;</code>这里通配符<code>?</code>表示一个通用类型，它所表示的泛型在编译的时候，被指定的具体的类型必须是<code>Fruit</code>的子类。比如<code>List&lt;? extend Fruit&gt; list= new ArrayList&lt;Apple&gt;</code>，<code>ArrayList&lt;&gt;</code>中指定的类型必须是<code>Apple</code>,<code>Orange</code>等。不要混淆。</blockquote>

概念麻烦，直接看代码：

<strong>协变泛型</strong>

<pre><code>
public static  void playFruit(List &lt; ? extends Fruit&gt; list){
    //do somthing
}

public static void main(String[] args) {
    List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
    List&lt;Orange&gt; oranges=new ArrayList&lt;&gt;();
    List&lt;Food&gt; foods =new ArrayList&lt;&gt;();
    playFruit(apples);
    playFruit(oranges);
    //playFruit(foods); 编译错误
}

</code></pre>

可以看到,参数<code>List &lt; ? extend Fruit&gt;</code>所表示是需要一个<code>List&lt;&gt;</code>，其中尖括号所指定的具体类型必须是继承自<code>Fruit</code>的。

这样便解决了泛型无法<strong>向上转型</strong>的问题,前面说过，数组也能向上转型，但是存取元素有问题啊，这里继续深入，看看泛型是怎么解决这一问题的。

<pre><code>  public static  void playFruit(List &lt; ? extends  Fruit&gt; list){
         list.add(new Apple());
    }
</code></pre>

向传入的<code>list</code>添加元素，你会发现编译器直接会报错

<strong>逆变泛型</strong>

<pre><code>public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
     //..
}

public static void main(String[] args) {
    List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
    List&lt;Food&gt; foods =new ArrayList&lt;&gt;();
    List&lt;Object&gt; objects=new ArrayList&lt;&gt;();
    playFruitBase(foods);
    playFruitBase(objects);
    //playFruitBase(apples); 编译错误
}

</code></pre>

同理，参数<code>List &lt; ? super Fruit&gt;</code>所表示是需要一个<code>List&lt;&gt;</code>,其中尖括号所指定的具体类型必须是<code>Fruit</code>的父类类型。

<pre><code>public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
    Object obj=list.get(0);
}
</code></pre>

取出<code>list</code>的元素，你会发现编译器直接会报错

<strong>思考：</strong> 为什么要这么麻烦要区分开到底是xxx的父类还是子类，不能直接使用一个关键字表示么？

前面说过，数组的协变之所以会有问题是因为在对数组中的元素进行存取的时候出现的问题，只要不对数组元素进行操作，就不会有什么问题，因此可以使用通配符<code>?</code>达到此效果：

<pre><code>public static void playEveryList(List &lt; ?&gt; list){
    //..
}
</code></pre>

对于<code>playEveryList</code>方法，传递任何类型的<code>List</code>都没有问题，但是你会发现对于<code>list</code>参数，你无法对里面的元素存和取。这样便达到了上面所说的<strong>安全类型的协变数组</strong>的效果。

但是觉得多数时候，我们还是希望对元素进行操作的，这就是<code>extend</code>和<code>super</code>的功能。

<strong><code>&lt;? extend Fruit&gt;</code></strong>表示传入的泛型具体类型必须是继承自<code>Fruit</code>，那么我们可以里面的元素一定能向上转型为<code>Fruit</code>。但是也仅仅能确定里面的元素一定能向上转型为<code>Fruit</code>

<pre><code>public static  void playFruit(List &lt; ? extends  Fruit&gt; list){
     Fruit fruit=list.get(0);
     //list.add(new Apple());
}
</code></pre>

比如上面这段代码，可以正确的取出元素，因为我们知道所传入的参数一定是继承自<code>Fruit</code>的，比如

<pre><code>List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
List&lt;Orange&gt; oranges=new ArrayList&lt;&gt;();
</code></pre>

都能正确的转换为<code>Fruit</code>，
<strong>但是</strong>我们并不知道里面的元素具体是什么，有可能是<code>Orange</code>，也有可能是<code>Apple</code>，因此，在<code>list.add()</code>的时候，就会出现问题，有可能将<code>Apple</code>放入了<code>Orange</code>里面，因此，为了不出错，编译器会禁止向里面加入任何元素。这也就解释了协变中使用<code>add</code>会出错的原因。

<hr />

同理：

<strong><code>&lt;? super Fruit&gt;</code></strong>表示传入的泛型具体类型必须是<code>Fruit</code>的<strong>父类</strong>，那么我们可以确定只要元素是<code>Fruit</code>以及能转型为<code>Fruit</code>的，一定能向上转型为对应的此类型,比如：

<pre><code>    public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
        list.add(new Apple());
    }
</code></pre>

因为<code>Apple</code>继承自<code>Fruit</code>，而参数list最终被指定的类型一定是<code>Fruit</code>的父类，那么<code>Apple</code>一定能向上转型为对应的<strong>父类</strong>，因此可以向里面存元素。

但是我们只能确定他是<code>Furit</code>的父类，并不知道具体的“上限”。因此无法将取出来的元素统一的类型(当然可以用<code>Object</code>)。比如

<pre><code>List&lt;Eatables&gt; eatables=new ArrayList&lt;&gt;();
List&lt;Food&gt; foods=new ArrayList&lt;&gt;();
</code></pre>

除了

<pre><code>Object obj;

obj=eatables.get(0);
obj=foods.get(0);
</code></pre>

之外，没有确定类型可以修饰<code>obj</code>以达到类似的效果。

针对上述情况。我们可以总结为：<strong>PECS</strong>原则，<code>Producer-Extend,Customer-Super</code>，也就是泛型代码是生产者，使用<code>Extend</code>，泛型代码作为消费者<code>Super</code>

<h3>泛型的阴暗角落</h3>

通过擦除而实现的泛型，有些时候会有很多让人难以理解的规则，但是了解了泛型的真正实现又会觉得这样做还是比较合情合理。下面分析一下关于泛型在应用中有哪些奇怪的现象：

<h4>擦除的地点---边界</h4>

<pre><code>    static &lt;T&gt; T[] toArray(T... args) {

        return args;
    }

    static &lt;T&gt; T[] pickTwo(T a, T b, T c) {
        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(a, b);
            case 1: return toArray(a, c);
            case 2: return toArray(b, c);
        }
        throw new AssertionError(); // Can't get here
    }

    public static void main(String[] args) {

        String[] attributes = pickTwo("Good", "Fast", "Cheap");
    }
</code></pre>

这是在《Effective Java》中看到的例子，编译此代码没有问题，但是运行的时候却会类型转换错误：<code>Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;</code>

当时对泛型并没有一个很好的认识，一直不明白为什么会有<code>Object[]</code>转换到<code>String[]</code>的错误。现在我们来分析一下：

<ul>
    <li>首先看<code>toArray</code>方法，由本章最开始所说泛型使用擦除实现的原因是为了保持有泛型和没有泛型所产生的代码一致，那么：</li>
</ul>

<pre><code>    static &lt;T&gt; T[] toArray(T... args) {
        return args;
    }
</code></pre>

和

<pre><code>static Object[] toArray(Object... args){
    return args;
}
</code></pre>

生成的二进制文件是一致的。

进而剥开可变数组的语法糖：

<pre><code>static Object[] toArray(Object[] args){
    return args;
}
</code></pre>

<pre><code>    static &lt;T&gt; T[] pickTwo(T a, T b, T c) {

        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(a, b);
            case 1: return toArray(a, c);
            case 2: return toArray(b, c);
        }

        throw new AssertionError(); // Can't get here
    }
</code></pre>

和

<pre><code>    static  Object[] pickTwo(Object a, Object b, Object c) {
        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(new Object[]{a,b});//可变参数会根据调用类型转换为对应的数组，这里a,b,c都是Object
            case 1: return toArray(new Object[]{a,b});
            case 2: return toArray(new Object[]{a,b});
        }

        throw new AssertionError(); // Can't get here
    }
</code></pre>

是一致的。
那么调用<code>pickTwo</code>方法实际编译器会帮我进行类型转换

<pre><code>    public static void main(String[] args) {
        String[] attributes =(String[])pickTwo("Good", "Fast", "Cheap");
    }
</code></pre>

可以看到，问题就在于可变参数那里，使用可变参数编译器会自动把我们的参数包装为一个数组传递给对应的方法，而这个数组的包装在泛型中，会最终翻译为<code>new Object</code>，那么<code>toArray</code>接受的实际类型是一个<code>Object[]</code>，当然不能强制转换为<code>String[]</code>

上面代码出错的关键点就在于泛型经过擦除后，类型变为了<code>Object</code>导致可变参数直接包装出了一个<code>Object</code>数组产生的类型转换失败。

<h4>基类劫持</h4>

<pre><code>public interface Playable&lt;T&gt;  {
    T play();
}

public class Base implements  Playable&lt;Integer&gt; {
    @Override
    public Integer play() {
        return 4;
    }
}

public class Derived extend Base implements Playable&lt;String&gt;{
    ...
}
</code></pre>

可以发现在定义<code>Derived</code>类的时候编译器会报错。
观察<code>Derived</code>的定义可以看到，它继承自<code>Base</code>
那么它就拥有一个<code>Integer play()</code>和方法，继而实现了<code>Playable&lt;String&gt;</code>接口，也就是它必须实现一个<code>String play()</code>方法。对于<code>Integer play()</code>和<code>String play()</code>两个方法的函数签名相同，但是返回类型不同，这样的方法在Java 中是不允许共存的：

<pre><code>public static void main(String[] args){
    new Derived().play();
}
</code></pre>

编译器并不知道应该调用哪一个<code>play()</code>方法。

<h4>自限定类型</h4>

自限定类型简单点说就是将泛型的类型限制为自己以及自己的子类。最常见的在于实现<code>Compareable</code>接口的时候：

<pre><code>public class Student implements Comparable&lt;Student&gt;{

}
</code></pre>

这样就成功的限制了能与<code>Student</code>相比较的类型只能是<code>Student</code>，这很好理解。

但是正如Java 中返回类型是协变的：

<pre><code>public class father{
    public Number test(){
        return nll;
    }
}


public class Son extend father{
    @Override
    public Interger test(){
        return null;
    }
}
</code></pre>

有些时候对于一些专门用来被继承的类需要<strong>参数</strong>也是协变的。比如实现一个<code>Enum</code>:

<pre><code>public abstract class Enum implements Comparable&lt;Enum&gt;,Serializable{
    @Override
    public int compareTo(Enum o) {
        return 0;
    }
}
</code></pre>

这样是没有问题的，但是正如常规所说，假如<code>Pen</code>和<code>Cup</code>都继承于<code>Enum</code>，但是按道理来说笔和杯子之间相互比较是没有意义的,也就是说在<code>Enum</code>中<code>compareTo(Enum o)</code>方法中的<code>Enum</code>这个限定词太宽泛，这个时候有两种思路：
1. 子类分别自己实现<code>Comparable</code>接口，这样就可以规定更详细的参数类型，但是由于前面所说，会出现基类劫持的问题
2. 修改父类的代码，让父类不实现<code>Comparable</code>接口，让每个子类自己实现即可，但是这样会有大量<strong>一模一样</strong>的代码，只是传入的参数类型不同而已。

而更好的解决方案便是使用泛型的自限定类型：

<pre><code>public abstract class Enum&lt;E extend Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;,Serializable{
    @Override
    public int compareTo(E o) {
        return 0;
    }

}
</code></pre>

泛型的自限定类型比起传统的自限定类型有个更大的优点就是它能使泛型的参数也变成协变的。

这样每个子类只用在集成的时候指定类型

<pre><code>public class Pen extends Enum&lt;Pen&gt;{}
public class Cup extends Cup&lt;Cup&gt;{}
</code></pre>

便能够在定义的时候指定想要与那种类型进行比较，这样达到的效果便相当于每个子类都分别自己实现了一个自定义的<code>Comparable</code>接口。

自限定类型一般用在继承体系中，需要参数协变的时候。

<blockquote>尊重原创，转载请注明出处</blockquote>

参考文章：
<a href="https://www.zhihu.com/question/28665443/answer/118148143">Java不能实现真正泛型的原因？ - RednaxelaFX的回答 - 知乎</a>
<a href="https://blog.csdn.net/u011240877/article/details/53545041">深入理解 Java 泛型</a>
<a href="https://www.zhihu.com/question/21394322/answer/121073103">java中，数组为什么要设计为协变？ - 胖君的回答 - 知乎</a>
<a href="https://ask.csdn.net/questions/678250">java泛型中的自限定类型有什么作用-CSDN问答</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>767</wp:post_id>
		<wp:post_date><![CDATA[2018-11-07 11:21:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-07 03:21:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-%e6%8a%80%e6%9c%af%e5%b9%b2%e8%b4%a7%e4%b9%8b%e6%b3%9b%e5%9e%8b__trashed]]></wp:post_name>
		<wp:status><![CDATA[trash]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="java"><![CDATA[Java]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="post_tag" nicename="%e5%b9%b2%e8%b4%a7"><![CDATA[干货]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<category domain="post_tag" nicename="%e6%b3%9b%e5%9e%8b"><![CDATA[泛型]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[26]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[java-%e6%8a%80%e6%9c%af%e5%b9%b2%e8%b4%a7%e4%b9%8b%e6%b3%9b%e5%9e%8b__trashed]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[22]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
			<wp:meta_value><![CDATA[publish]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
			<wp:meta_value><![CDATA[1543974229]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_desired_post_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[java-%e6%8a%80%e6%9c%af%e5%b9%b2%e8%b4%a7%e4%b9%8b%e6%b3%9b%e5%9e%8b]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ces</title>
		<link>http://dengchengchao.com/?p=874</link>
		<pubDate>Wed, 21 Nov 2018 09:24:49 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=874</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>
  一般的类和方法，只能使用具体的类型，要么是基本类型，要么是自定义的类。如果要编写可以应用多中类型的代码，这种刻板的限制对代码得束缚会就会很大。
                                                    ---《Thinking in Java》
</blockquote>

泛型大家都接触的不少，但是由于Java 历史的原因，Java 中的泛型一直被称为<em>伪泛型</em>,因此对Java中的泛型，有很多不注意就会遇到的“坑”,在这里详细讨论一下。对于基础而又常见的语法，这里就直接略过了。

<h3>什么是泛型</h3>

自JDK 1.5 之后，Java 通过泛型解决了容器类型安全这一问题，而几乎所有人接触泛型也是通过Java的容器。那么泛型究竟是什么？<br />
<strong>泛型的本质是参数化类型</strong><br />
也就是说，泛型就是将所操作的数据类型作为参数的一种语法。

<pre><code>public class Paly&lt;T&gt;{
    T play(){}
}
</code></pre>

其中<code>T</code>就是作为一个类型参数在<code>Play</code>被实例化的时候所传递来的参数，比如：

<pre><code>Play&lt;Integer&gt; playInteger=new Play&lt;&gt;();
</code></pre>

这里<code>T</code>就会被实例化为<code>Integer</code>

<h3>泛型的作用</h3>

<h5>- 使用泛型能写出更加灵活通用的代码</h5>

泛型的设计主要参照了C++的模板，旨在能让人写出更加通用化，更加灵活的代码。模板/泛型代码，就好像做雕塑时的模板，有了模板，需要生产的时候就只管向里面注入具体的材料就行，不同的材料可以产生不同的效果，这便是泛型最初的设计宗旨。

<h5>- 泛型将代码安全性检查提前到编译期</h5>

泛型被加入Java语法中，还有一个最大的原因：解决容器的类型安全，使用泛型后，能让编译器在编译的时候借助传入的类型参数检查对容器的插入，获取操作是否合法，从而将<strong>运行时</strong><code>ClassCastException</code>转移到<strong>编译时</strong>比如：

<pre><code>List dogs =new ArrayList();
dogs.add(new Cat());
</code></pre>

在没有泛型之前，这种代码除非运行，否则你永远找不到它的错误。但是加入泛型后

<pre><code>List&lt;Dog&gt; dogs=new ArrayList&lt;&gt;();
dogs.add(new Cat());//Error Compile
</code></pre>

会在编译的时候就检查出来。

<h5>- 泛型能够省去类型强制转换</h5>

在JDK1.5之前，Java容器都是通过将类型向上转型为<code>Object</code>类型来实现的，因此在从容器中取出来的时候需要手动的强制转换。

<pre><code>Dog dog=(Dog)dogs.get(1);
</code></pre>

加入泛型后，由于编译器知道了具体的类型，因此编译期会自动进行强制转换，使得代码更加优雅。

<h3>泛型的具体实现</h3>

我们可以定义泛型类，泛型方法，泛型接口等，那泛型的底层是怎么实现的呢？

<h4>从历史上看泛型</h4>

由于泛型是JDK1.5之后才出现的，在此之前需要使用泛型(模板代码)的地方都是通过<code>Object</code>向上转型以及强制类型转换实现的,这样虽然能满足大多数需求，但是有个最大的问题就在于类型安全。在获取“真正”的数据的时候，如果不小心强制转换成了错误类型，这种错误只能在真正运行的时候才能发现。

因此Java 1.5推出了“泛型”，也就是在原本的基础上加上了编译时类型检查的语法糖。Java 的泛型推出来后，引起来很多人的吐槽，因为相对于C++等其他语言的泛型，Java的泛型代码的灵活性依然会受到很多限制。这是因为Java被规定必须<strong>保持二进制向后兼容性</strong>，也就是一个在Java 1.4版本中可以正常运行的Class文件，放在Java 1.5中必须是能够正常运行的:

在1.5之前，这种类型的代码是没有问题的。

<pre><code>public static void addRawList(List list){
   list.add("123");
   list.add(2);
}
</code></pre>

1.5之后泛型大量应用后：

<pre><code>public static void addGenericList(List&lt;String&gt; list){
    list.add("1");//Only String
    list.add("2");
}
</code></pre>

虽然我们认为<code>addRawList()</code>方法中的代码不是类型安全的，但是某些时候这种代码是有用的，在设计JDK1.5的时候，想要实现泛型有两种选择：

<ul>
<li>需要泛型化的类型（主要是容器（Collections）类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型；</li>
<li>直接把已有的类型泛型化，让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</li>
</ul>

什么意思呢？也就是第一种办法是在原有的Java库的基础上，再添加一些库，这些库的功能和原本的一模一样，只是这些库是使用Java新语法泛型实现的，而第二种办法是保持和原本的库的高度一致性，不添加任何新的库。

在出现了泛型之后，原本没有使用泛型的代码就被称为<code>raw type</code>(原始类型)
Java 的二进制向后兼容性使得Java 需要实现前后兼容的泛型，也就是说以前使用原始类型的代码可以继续被泛型使用，现在的泛型也可以作为参数传递给原始类型的代码。
比如

<pre><code> List&lt;String&gt; list=new ArrayList&lt;&gt;();
 List rawList=new ArrayList();
 addRawList(list);
 addGenericList(list);

 addRawList(rawList);
 addGenericList(rawList);
</code></pre>

上面的代码能够正确的运行。

Java 设计者选择了第二种方案

<blockquote>
  C# 在1.1过渡到2.0中增加泛型时，使用了第一种方案。
</blockquote>

<hr />

为了实现以上功能，Java 设计者将泛型完全作为了<strong>语法糖</strong>加入了新的语法中，什么意思呢？也就是说泛型对于JVM来说是透明的，有泛型的和没有泛型的代码，通过编译器编译后所生成的二进制代码是完全相同的。

这个语法糖的实现被称为<strong>擦除</strong>

<h4>擦除的过程</h4>

<strong>泛型</strong>是为了将具体的类型作为参数传递给方法，类，接口。<br />
<strong>擦除</strong>是在代码运行过程中将具体的类型都抹除。

前面说过，Java 1.5 之前需要编写模板代码的地方都是通过<code>Object</code>来保存具体的值。比如：

<pre><code>public class Node{
   private Object obj;

   public Object get(){
       return obj;
   }

   public void set(Object obj){
       this.obj=obj;
   }

   public static void main(String[] argv){

    Student stu=new Student();
    Node  node=new Node();
    node.set(stu);
    Student stu2=(Student)node.get();
   }
}


</code></pre>

这样的实现能满足绝大多数需求，但是泛型还是有更多方便的地方，最大的一点就是编译期类型检查，于是Java 1.5之后加入了泛型，但是这个泛型仅仅是在编译的时候帮你做了编译时类型检查，成功编译后所生成的<code>.class</code>文件还是一模一样的，这便是擦除

1.5 以后实现

<pre><code>public class Node&lt;T&gt;{

    private T obj;

    public T get(){

        return obj;
    }

    public void set(T obj){
        this.obj=obj;
    }

    public static void main(String[] argv){

    Student stu=new Student();
    Node&lt;Student&gt;  node=new Node&lt;&gt;();
    node.set(stu);
    Student stu2=node.get();
  }
}
</code></pre>

两个版本生成的.class文件：
Node:

<pre><code>  public Node();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return
  public java.lang.Object get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn
  public void set(java.lang.Object);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return
}

</code></pre>

Node&lt; T>

<pre><code>public class Node&lt;T&gt; {
  public Node();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return
  public T get();
    Code:
       0: aload_0
       1: getfield      #2                  // Field obj:Ljava/lang/Object;
       4: areturn

  public void set(T);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field obj:Ljava/lang/Object;
       5: return
}

</code></pre>

可以看到泛型就是在使用泛型代码的时候，将<strong>类型信息</strong>传递给具体的泛型代码。而经过编译后，生成的<code>.class</code>文件和原始的代码一模一样，就好像传递过来的<strong>类型信息</strong>又被擦除了一样。

<h4>泛型语法</h4>

Java 的泛型就是一个<strong>语法糖</strong>，而语法糖最大的好处就是让人方便使用，但是它的缺点也在于如果不剥开这颗语法糖，有很多奇怪的语法就很难理解。

<ul>
<li><strong>类型边界</strong><br />
前面说过，泛型在最终会擦除为<code>Object</code>类型。这样导致的是在编写泛型代码的时候，对泛型元素的操作只能使用<code>Object</code>自带的一些方法，但是有时候我们想使用其他类型的方法呢？
比如：</li>
</ul>

<pre><code>public class Node{
    private People obj;
    public People get(){

        return obj;
    }

    public void set(People obj){
        this.obj=obj;
    }

    public void playName(){
        System.out.println(obj.getName());
    }
}
</code></pre>

如上，代码中需要使用<code>obj.getName()</code>方法，因此比如规定传入的元素必须是<code>People</code>及其子类，那么这样的方法怎么通过泛型体现出来呢？<br />
答案是<code>extend</code>，泛型重载了<code>extend</code>关键字，可以通过<code>extend</code>关键字指定最终擦除所替代的类型。

<pre><code>public class Node&lt;T extend People&gt;{

    private T obj;

    public T get(){

        return obj;
    }

    public void set(T obj){
        this.obj=obj;
    }

    public void playName(){
        System.out.println(obj.getName());
    }
}
</code></pre>

通过<code>extend</code>关键字，编译器会将最后类型都擦除为<code>People</code>类型，就好像最开始我们看见的原始代码一样。

<h4>泛型与向上转型的概念</h4>

先讲一讲几个概念：

<ul>
<li>协变：子类能向父类转换 <code>Animal a1=new Cat();</code></li>
<li>逆变: 父类能向子类转换 <code>Cat a2=(Cat)a1;</code></li>
<li>不变: 两者均不能转变</li>
</ul>

对于协变，我们见得最多的就是多态,而逆变常见于强制类型转换。
这好像没什么奇怪的。但是看以下代码：

<pre><code>public static void error(){
   Object[] nums=new Integer[3];
   nums[0]=3.2;
   nums[1]="string"; //运行时报错，nums运行时类型是Integer[]
   nums[2]='2';
 }
</code></pre>

因为数组是协变的，因此<code>Integer[]</code>可以转换为<code>Object[]</code>，在编译阶段编译器只知道<code>nums</code>是<code>Object[]</code>类型，而运行时<code>nums</code>则为<code>Integer[]</code>类型，因此上述代码能够编译，但是运行会报错。

这就是常见的人们所说的数组是协变的。这里带来一个问题，为什么数组要设计为协变的呢？既然不让运行，那么通过编译有什么用？

答案是在泛型还没出现之前，数组协变能够解决一些通用的问题：

<pre><code>public static void sort(Object[] a) {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a);
        else
            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
    }

</code></pre>

<pre><code>/**
 * 摘自JDK 1.8 Arrays.equals()
 */
  public static boolean equals(Object[] a, Object[] a2) {
        //...
        for (int i=0; i&lt;length; i++) {
            Object o1 = a[i];
            Object o2 = a2[i];
            if (!(o1==null ? o2==null : o1.equals(o2)))
                return false;
        }
        //..
        return true;
    }

</code></pre>

可以看到，<strong>只操作数组本身，而不关心数组中具体保存的元素</strong>，或者是不管什么元素，取出来就作为一个<code>Object</code>存储的时候，只用编写一个<code>Object[]</code>就能写出通用的数组参数方法。比如：

<pre><code>Arrays.sort(new Student[]{...})
Arrays.sort(new Apple[]{...})
</code></pre>

等，但是这样的设计留下来的诟病就是偶尔会出现对<strong>数组元素有具体的操作</strong>的代码，比如上面的<code>error()</code>方法。

<strong>泛型</strong>的出现，是为了保证类型安全的问题，如果将泛型也设计为协变的话，那也就违背了泛型最初设计的初衷，因此在Java中，泛型是不变的，什么意思呢？

<blockquote>
  <code>List&lt;Number&gt;</code> 和 <code>List&lt;Integer&gt;</code> 是没有任何关系的，即使<code>Integer</code> 是 <code>Number</code>的子类
</blockquote>

也就是对于

<pre><code>public static void test(List&lt; Number&gt; nums){...}
</code></pre>

方法，是无法传递一个<code>List&lt;Integer&gt;</code>参数的

逆变一般常见于强制类型转换。

<pre><code>Object obj="test";
String str=(String)obj;
</code></pre>

原理便是Java 反射机制能够记住变量<code>obj</code>的实际类型，在强制类型转换的时候发现<code>obj</code>实际上是一个<code>String</code>类型，于是就正常的通过了运行。

<h4>泛型与向上转型的实现</h4>

前面说了这么多，应该关心的问题在于，如何解决既能使用数组协变带来的方便性，又能得到泛型不变带来的类型安全？

答案依然是<code>extend</code>,<code>super</code>关键字与通配符<code>?</code>

泛型重载了<code>extend</code>，<code>super</code>关键字来解决通用泛型的表示。

<blockquote>
  注意：这句话可能比较熟悉，没错，前面说过<code>extend</code>还被用来指定擦除到的具体类型，比如<code>&lt;E extend Fruit&gt;</code>，表示在运行时将<code>E</code>替换为<code>Fruit</code>,注意<code>E</code>表示的是一个具体的类型，但是这里的<code>extend</code>和通配符连续使用<code>&lt;? extend Fruit&gt;</code>这里通配符<code>?</code>表示一个通用类型，它所表示的泛型在编译的时候，被指定的具体的类型必须是<code>Fruit</code>的子类。比如<code>List&lt;? extend Fruit&gt; list= new ArrayList&lt;Apple&gt;</code>，<code>ArrayList&lt;&gt;</code>中指定的类型必须是<code>Apple</code>,<code>Orange</code>等。不要混淆。
</blockquote>

概念麻烦，直接看代码：

<strong>协变泛型</strong>

<pre><code><br />public static  void playFruit(List &lt; ? extends Fruit&gt; list){
    //do somthing
}

public static void main(String[] args) {
    List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
    List&lt;Orange&gt; oranges=new ArrayList&lt;&gt;();
    List&lt;Food&gt; foods =new ArrayList&lt;&gt;();
    playFruit(apples);
    playFruit(oranges);
    //playFruit(foods); 编译错误
}

</code></pre>

可以看到,参数<code>List &lt; ? extend Fruit&gt;</code>所表示是需要一个<code>List&lt;&gt;</code>，其中尖括号所指定的具体类型必须是继承自<code>Fruit</code>的。

这样便解决了泛型无法<strong>向上转型</strong>的问题,前面说过，数组也能向上转型，但是存取元素有问题啊，这里继续深入，看看泛型是怎么解决这一问题的。

<pre><code>  public static  void playFruit(List &lt; ? extends  Fruit&gt; list){
         list.add(new Apple());
    }
</code></pre>

向传入的<code>list</code>添加元素，你会发现编译器直接会报错

<strong>逆变泛型</strong>

<pre><code>public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
     //..
}

public static void main(String[] args) {
    List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
    List&lt;Food&gt; foods =new ArrayList&lt;&gt;();
    List&lt;Object&gt; objects=new ArrayList&lt;&gt;();
    playFruitBase(foods);
    playFruitBase(objects);
    //playFruitBase(apples); 编译错误
}

</code></pre>

同理，参数<code>List &lt; ? super Fruit&gt;</code>所表示是需要一个<code>List&lt;&gt;</code>,其中尖括号所指定的具体类型必须是<code>Fruit</code>的父类类型。

<pre><code>public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
    Object obj=list.get(0);
}
</code></pre>

取出<code>list</code>的元素，你会发现编译器直接会报错

<strong>思考：</strong> 为什么要这么麻烦要区分开到底是xxx的父类还是子类，不能直接使用一个关键字表示么？

前面说过，数组的协变之所以会有问题是因为在对数组中的元素进行存取的时候出现的问题，只要不对数组元素进行操作，就不会有什么问题，因此可以使用通配符<code>?</code>达到此效果：

<pre><code>public static void playEveryList(List &lt; ?&gt; list){
    //..
}
</code></pre>

对于<code>playEveryList</code>方法，传递任何类型的<code>List</code>都没有问题，但是你会发现对于<code>list</code>参数，你无法对里面的元素存和取。这样便达到了上面所说的<strong>安全类型的协变数组</strong>的效果。

但是觉得多数时候，我们还是希望对元素进行操作的，这就是<code>extend</code>和<code>super</code>的功能。

<strong><code>&lt;? extend Fruit&gt;</code></strong>表示传入的泛型具体类型必须是继承自<code>Fruit</code>，那么我们可以里面的元素一定能向上转型为<code>Fruit</code>。但是也仅仅能确定里面的元素一定能向上转型为<code>Fruit</code>

<pre><code>public static  void playFruit(List &lt; ? extends  Fruit&gt; list){
     Fruit fruit=list.get(0);
     //list.add(new Apple());
}
</code></pre>

比如上面这段代码，可以正确的取出元素，因为我们知道所传入的参数一定是继承自<code>Fruit</code>的，比如

<pre><code>List&lt;Apple&gt; apples=new ArrayList&lt;&gt;();
List&lt;Orange&gt; oranges=new ArrayList&lt;&gt;();
</code></pre>

都能正确的转换为<code>Fruit</code>，
<strong>但是</strong>我们并不知道里面的元素具体是什么，有可能是<code>Orange</code>，也有可能是<code>Apple</code>，因此，在<code>list.add()</code>的时候，就会出现问题，有可能将<code>Apple</code>放入了<code>Orange</code>里面，因此，为了不出错，编译器会禁止向里面加入任何元素。这也就解释了协变中使用<code>add</code>会出错的原因。

<hr />

同理：

<strong><code>&lt;? super Fruit&gt;</code></strong>表示传入的泛型具体类型必须是<code>Fruit</code>的<strong>父类</strong>，那么我们可以确定只要元素是<code>Fruit</code>以及能转型为<code>Fruit</code>的，一定能向上转型为对应的此类型,比如：

<pre><code>    public  static  void playFruitBase(List &lt; ? super  Fruit&gt; list){
        list.add(new Apple());
    }
</code></pre>

因为<code>Apple</code>继承自<code>Fruit</code>，而参数list最终被指定的类型一定是<code>Fruit</code>的父类，那么<code>Apple</code>一定能向上转型为对应的<strong>父类</strong>，因此可以向里面存元素。

但是我们只能确定他是<code>Furit</code>的父类，并不知道具体的“上限”。因此无法将取出来的元素统一的类型(当然可以用<code>Object</code>)。比如

<pre><code>List&lt;Eatables&gt; eatables=new ArrayList&lt;&gt;();
List&lt;Food&gt; foods=new ArrayList&lt;&gt;();
</code></pre>

除了

<pre><code>Object obj;

obj=eatables.get(0);
obj=foods.get(0);
</code></pre>

之外，没有确定类型可以修饰<code>obj</code>以达到类似的效果。

针对上述情况。我们可以总结为：<strong>PECS</strong>原则，<code>Producer-Extend,Customer-Super</code>，也就是泛型代码是生产者，使用<code>Extend</code>，泛型代码作为消费者<code>Super</code>

<h3>泛型的阴暗角落</h3>

通过擦除而实现的泛型，有些时候会有很多让人难以理解的规则，但是了解了泛型的真正实现又会觉得这样做还是比较合情合理。下面分析一下关于泛型在应用中有哪些奇怪的现象：

<h4>擦除的地点---边界</h4>

<pre><code>    static &lt;T&gt; T[] toArray(T... args) {

        return args;
    }

    static &lt;T&gt; T[] pickTwo(T a, T b, T c) {
        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(a, b);
            case 1: return toArray(a, c);
            case 2: return toArray(b, c);
        }
        throw new AssertionError(); // Can't get here
    }

    public static void main(String[] args) {

        String[] attributes = pickTwo("Good", "Fast", "Cheap");
    }
</code></pre>

这是在《Effective Java》中看到的例子，编译此代码没有问题，但是运行的时候却会类型转换错误：<code>Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;</code>

当时对泛型并没有一个很好的认识，一直不明白为什么会有<code>Object[]</code>转换到<code>String[]</code>的错误。现在我们来分析一下：

<ul>
<li>首先看<code>toArray</code>方法，由本章最开始所说泛型使用擦除实现的原因是为了保持有泛型和没有泛型所产生的代码一致，那么：</li>
</ul>

<pre><code>    static &lt;T&gt; T[] toArray(T... args) {
        return args;
    }
</code></pre>

和

<pre><code>static Object[] toArray(Object... args){
    return args;
}
</code></pre>

生成的二进制文件是一致的。

进而剥开可变数组的语法糖：

<pre><code>static Object[] toArray(Object[] args){
    return args;
}
</code></pre>

<pre><code>    static &lt;T&gt; T[] pickTwo(T a, T b, T c) {

        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(a, b);
            case 1: return toArray(a, c);
            case 2: return toArray(b, c);
        }

        throw new AssertionError(); // Can't get here
    }
</code></pre>

和

<pre><code>    static  Object[] pickTwo(Object a, Object b, Object c) {
        switch(ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(new Object[]{a,b});//可变参数会根据调用类型转换为对应的数组，这里a,b,c都是Object
            case 1: return toArray(new Object[]{a,b});
            case 2: return toArray(new Object[]{a,b});
        }

        throw new AssertionError(); // Can't get here
    }
</code></pre>

是一致的。
那么调用<code>pickTwo</code>方法实际编译器会帮我进行类型转换

<pre><code>    public static void main(String[] args) {
        String[] attributes =(String[])pickTwo("Good", "Fast", "Cheap");
    }
</code></pre>

可以看到，问题就在于可变参数那里，使用可变参数编译器会自动把我们的参数包装为一个数组传递给对应的方法，而这个数组的包装在泛型中，会最终翻译为<code>new Object</code>，那么<code>toArray</code>接受的实际类型是一个<code>Object[]</code>，当然不能强制转换为<code>String[]</code>

上面代码出错的关键点就在于泛型经过擦除后，类型变为了<code>Object</code>导致可变参数直接包装出了一个<code>Object</code>数组产生的类型转换失败。

<h4>基类劫持</h4>

<pre><code>public interface Playable&lt;T&gt;  {
    T play();
}

public class Base implements  Playable&lt;Integer&gt; {
    @Override
    public Integer play() {
        return 4;
    }
}

public class Derived extend Base implements Playable&lt;String&gt;{
    ...
}
</code></pre>

可以发现在定义<code>Derived</code>类的时候编译器会报错。
观察<code>Derived</code>的定义可以看到，它继承自<code>Base</code>
那么它就拥有一个<code>Integer play()</code>和方法，继而实现了<code>Playable&lt;String&gt;</code>接口，也就是它必须实现一个<code>String play()</code>方法。对于<code>Integer play()</code>和<code>String play()</code>两个方法的函数签名相同，但是返回类型不同，这样的方法在Java 中是不允许共存的：

<pre><code>public static void main(String[] args){
    new Derived().play();
}
</code></pre>

编译器并不知道应该调用哪一个<code>play()</code>方法。

<h4>自限定类型</h4>

自限定类型简单点说就是将泛型的类型限制为自己以及自己的子类。最常见的在于实现<code>Compareable</code>接口的时候：

<pre><code>public class Student implements Comparable&lt;Student&gt;{

}
</code></pre>

这样就成功的限制了能与<code>Student</code>相比较的类型只能是<code>Student</code>，这很好理解。

但是正如Java 中返回类型是协变的：

<pre><code>public class father{
    public Number test(){
        return nll;
    }
}


public class Son extend father{
    @Override
    public Interger test(){
        return null;
    }
}
</code></pre>

有些时候对于一些专门用来被继承的类需要<strong>参数</strong>也是协变的。比如实现一个<code>Enum</code>:

<pre><code>public abstract class Enum implements Comparable&lt;Enum&gt;,Serializable{
    @Override
    public int compareTo(Enum o) {
        return 0;
    }
}
</code></pre>

这样是没有问题的，但是正如常规所说，假如<code>Pen</code>和<code>Cup</code>都继承于<code>Enum</code>，但是按道理来说笔和杯子之间相互比较是没有意义的,也就是说在<code>Enum</code>中<code>compareTo(Enum o)</code>方法中的<code>Enum</code>这个限定词太宽泛，这个时候有两种思路：
1. 子类分别自己实现<code>Comparable</code>接口，这样就可以规定更详细的参数类型，但是由于前面所说，会出现基类劫持的问题
2. 修改父类的代码，让父类不实现<code>Comparable</code>接口，让每个子类自己实现即可，但是这样会有大量<strong>一模一样</strong>的代码，只是传入的参数类型不同而已。

而更好的解决方案便是使用泛型的自限定类型：

<pre><code>public abstract class Enum&lt;E extend Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;,Serializable{
    @Override
    public int compareTo(E o) {
        return 0;
    }

}
</code></pre>

泛型的自限定类型比起传统的自限定类型有个更大的优点就是它能使泛型的参数也变成协变的。

这样每个子类只用在集成的时候指定类型

<pre><code>public class Pen extends Enum&lt;Pen&gt;{}
public class Cup extends Cup&lt;Cup&gt;{}
</code></pre>

便能够在定义的时候指定想要与那种类型进行比较，这样达到的效果便相当于每个子类都分别自己实现了一个自定义的<code>Comparable</code>接口。

自限定类型一般用在继承体系中，需要参数协变的时候。

<blockquote>
  尊重原创，转载请注明出处
</blockquote>

参考文章：<br />
<a href="https://www.zhihu.com/question/28665443/answer/118148143">Java不能实现真正泛型的原因？ - RednaxelaFX的回答 - 知乎</a><br />
<a href="https://blog.csdn.net/u011240877/article/details/53545041">深入理解 Java 泛型</a><br />
<a href="https://www.zhihu.com/question/21394322/answer/121073103">java中，数组为什么要设计为协变？ - 胖君的回答 - 知乎</a><br />
<a href="https://ask.csdn.net/questions/678250">java泛型中的自限定类型有什么作用-CSDN问答</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>874</wp:post_id>
		<wp:post_date><![CDATA[2018-11-21 17:24:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-11-21 09:24:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ces__trashed-2]]></wp:post_name>
		<wp:status><![CDATA[trash]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e6%9d%82%e8%ae%b0"><![CDATA[杂记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
			<wp:meta_value><![CDATA[publish]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
			<wp:meta_value><![CDATA[1542792332]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_desired_post_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[ces]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>简单总结Java对象在虚拟机中的创建过程</title>
		<link>http://dengchengchao.com/?p=929</link>
		<pubDate>Mon, 10 Dec 2018 12:35:20 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=929</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Java 对象在虚拟机中的创建过程</h3>

首先总结一张图：

<img src="http://dengchengchao.com/wp-content/uploads/2018/12/classLoad.png" alt="image" />

可以看到还是比较复杂的。

这里简单总结下，具体的细节以后再分析：

在new 一个对象的时候，会发生如下操作：

首先是<strong>类加载</strong>，类加载会在Class第一次被引用的时候加载，类加载分为三个大部分：

<ul>
<li><strong>加载 :</strong> 通过环境变量加类的全量路径查找该类</li>
<li><strong>连接</strong>

<ul>
<li><strong>验证:</strong> 验证class文件的合法性</li>
<li><strong>准备:</strong>为静态变量分配内存，并设置初始值</li>
<li><strong>解析:</strong>将符号引用替换为直接引用</li>
</ul></li>
<li><strong>初始化:</strong>初始化静态变量</li>
</ul>

总体来说，类加载就是用来加载Class对象的步骤。

总体分为三个步骤，加载，连接，初始化，其中连接又可以分为验证，准备，解析

静态变量的内存分配在连接操作的准备阶段，静态变量的初始化阶段在类加载阶段的初始化阶段。

然后是<strong>分配内存</strong>，注意这里的内存分配是为所实例化的对象分配内存，也就是<code>对象的属性</code>，<code>类属性</code>已经在类加载过程中的准备阶段分配并初始化。

内存分配包含两种方式：若是连续内存则使用<code>指针碰撞</code>方式，若是不连续内存则使用<code>空闲列表</code>的方式分配

在内存分配中存在线程安全的问题，解决方式为：在每次开启线程的时候，都<code>为每个线程分配一段独立的空间</code>，线程所需要分配的内存都在该空间分配（TLAB），当线程空间使用完毕的时候，使用<code>CAS</code>锁再次分配内存。

内存分配完毕后则进行<strong>内存初始化</strong>，内存初始化的作用是将内存都初始化为默认值，比如基本数据类型为0，<code>boolean</code>为<code>false</code>，对象为<code>null</code>

接下来最后一步是<strong>执行构造函数</strong>，为成员属性附上初始值,这里值得注意的一点便是为对象设置默认值有两种方式，第一种是在声明的时候初始化，第二种是只声明，具体的值在构造函数中初始化:

<pre><code class="java">private int a=0;
private int b;

public Test(){
    b=2;
}
</code></pre>

但是经过编译后的class文件你会发现，声明时初始化其实就是一个语法糖，它的具体初始化还是在构造函数中。

<strong>总结可得</strong>:对象创建过程为：先初始化类对象，再初始化实例。类对象中静态变量的内存分配阶段为类加载的准备阶段，初始化阶段为类加载中的初始化阶段。接下来便是实例的内存分配，赋默认值，最后执行构造函数。

<strong>问题：</strong>

看完上面的总结，思考下面的程序输出什么？为什么？

<pre><code class="java">public class Test(){
    public static Test instance=new Test();
    private int a;
    private static int b=2;

    public Test(){
       a++;
       System.out.printf("a: %d  b: %d \n",a,b);   
    }



    public static void main(String args[]){
        Test t=new Test();
    }
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>929</wp:post_id>
		<wp:post_date><![CDATA[2018-12-10 20:35:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-10 12:35:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ae%80%e5%8d%95%e6%80%bb%e7%bb%93java%e5%af%b9%e8%b1%a1%e5%9c%a8%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%ad%e7%9a%84%e5%88%9b%e5%bb%ba%e8%bf%87%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="jvm"><![CDATA[JVM]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<category domain="post_tag" nicename="%e7%b1%bb%e5%8a%a0%e8%bd%bd"><![CDATA[类加载]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>简单了解 JavaAgent</title>
		<link>http://dengchengchao.com/?p=933</link>
		<pubDate>Fri, 14 Dec 2018 02:45:22 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=933</guid>
		<description></description>
		<content:encoded><![CDATA[某天，在使用不正当途径激活我的IDEA编辑器的时候，发现最后一步需要在idea的启动项配置文件中添加一个参数：<code>-javaagent xxxx.jar</code>

然后我的IDEA就成功激活了，<code>-javaagent</code>是什么？

<h4>javaagent</h4>

<code>javaagent</code>是JDK1.5添加的一个新特性，使用<code>javaagent</code>可以实现很多类似线上诊断方面的工具，因为它可以在不改源代码的基础上，动态修改代码的行为。像类似<code>btrace</code>和阿里开源的<code>arthas</code>都是基于<code>javaagent</code>所实现的。

<code>talk is cheap show me the code</code>

看了代码，才能真正的了解到<code>javaagent</code>的威力

首先，编写一个简单的业务逻辑处理类：

<pre><code class="java">public class Service {

    public  boolean update(){
        System.out.println("更新成功");
        return true;
    }

    public boolean insert(){
        System.out.println("插入成功");
        return true;
    }
}

</code></pre>

简单的更新和插入操作。

然后编写我们的<code>javaagent</code>包,<code>javaagent</code>需要被完整的打包成一个<code>jar</code>包，因此我们可以先新建一个<code>Maven</code>项目，然后编写<code>ServiceClassFileTransformer</code>用来修改刚刚编写的<code>Service</code>类。

<pre><code class="java">import javassist.*;

import java.io.IOException;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.security.ProtectionDomain;

/**
 * @author dengchengchao
 * @date 2018/12/8 18:38
 */
public class ServiceClassFileTransformer implements ClassFileTransformer {

    @Override
    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
        if (!"com/dengchengchao/Service".equals(className)) return null;

        //className是以/分割，这里需要替换为.否则会报错
        className = className.replaceAll("/", ".");
        try{
            CtClass ctClass= ClassPool.getDefault().get(className);
            CtMethod method=ctClass.getDeclaredMethod("update");
            //向字节码插入代码
            method.insertBefore("{System.out.println(\"代码被插入\");}");
            return ctClass.toBytecode();

        }catch (NotFoundException | CannotCompileException | IOException e){        
            e.printStackTrace();
        }
        return new byte[0];
    }

    //定义premain，而不是main,使得这个方法在Service的mian方法执行之前执行
    public  static void premain(String options, Instrumentation ins){
        ins.addTransformer(new ServiceClassFileTransformer());
    }
}

</code></pre>

主要内容便是我们需要实现<code>ClassFileTransformer</code>接口中的<code>transform</code>方法，<code>transform</code>方法中，我们使用了<code>javassist</code>来修改原本的代码的字节码。

在<code>ServiceClassFileTransformer</code>类中，还包含一个<code>premain</code>方法，性质和<code>main</code>一样，都是作为入口函数。在JDK1.6后还添加了一个方法

<pre><code class="java">  public  static  void agentmain(String agentArgs, Instrumentation inst){     
   }
</code></pre>

用来以<code>Attach</code>的方式载入，用于在Java程序启动后执行，这里不做过多研究。

编写完<code>ClassFileTransformer</code>的实现以后，还需要最后一步，添加<code>MANIFEST</code>文件，我们可以手动指定，也可以使用Maven配置：

手动指定的话，我们可以在<code>src</code>目录下添加一个<code>META-INF</code>文件夹，然后创建一个<code>MANIFEST.MF</code>文件

在文件中指定<code>Agent</code>的启动类：

<pre><code class="java">Mainfest-Version:1.0
Agent-Class:com.dengchengchao.utils.ServiceClassFileTransformer
Premian-Class:com.dengchengchao.utils.ServiceClassFileTransformer
Can-Redefine-Classes:true
Can-Retransform-Classes:true
</code></pre>

这里最主要的便是指定<code>Premain-Class</code>，就像普通的<code>NABUFEST.MF</code>文件是用来指定<code>main</code>入口一样。

如果编写的是<code>static void premain</code>方法作为主要入口，那就指定<code>Prmain-Class</code>，

如果是<code>static  void agentmain</code>,那就指定<code>Agent-Class</code>

如果不想手动编写，想使用<code>Maven</code>配置的话，可以在<code>POM</code>中添加如下配置：

<pre><code class="java">&lt;plugin&gt;
    &lt;artifactId&gt; maven-assembly-plugin &lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;descriptorRefs&gt;
             &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
        &lt;/descriptorRefs&gt;
        &lt;archive&gt;
           &lt;manifestEntries&gt;
                 &lt;Premain-Class&gt;
                      com.dengchengchao.util.ServiceClassFileTransformer
                 &lt;/Premain-Class&gt;
             &lt;/manifestEntries&gt;
         &lt;/archive&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
       &lt;execution&gt;
          &lt;id&gt;make-assembly&lt;/id&gt;
          &lt;phase&gt;package&lt;/phase&gt;
          &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
          &lt;/goals&gt;
       /execution&gt;
     &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>

然后打包成jar包,名字修改为<code>aop.jar</code>。

接下来回到编写<code>Service</code>类的项目工程中，测试<code>Service</code>

<pre><code class="java">    public static void main(String args[]) {
        Service service = new Service();
        service.update();

    }

</code></pre>

在启动配置中，添加VM启动项：<code>-javaagent F:\utils\target\aop.jar</code>

<blockquote>
  IDEA添加方法为选择相关项目,<code>Edit Configurations</code> ,添加VM options即可，
</blockquote>

运行：我们会得到如下结果：

<pre><code class="java">代码被插入
更新成功
</code></pre>

也就是说，我们在没有修改<code>Service</code>源码的情况下，却修改了它的方法。

回想IDEA的破解配置，猜想他可能是通过拆包找到了IDEA的验证配置方法，直接返回验证成功。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>933</wp:post_id>
		<wp:post_date><![CDATA[2018-12-14 10:45:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-14 02:45:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ae%80%e5%8d%95%e4%ba%86%e8%a7%a3-javaagent]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="javaagent"><![CDATA[JavaAgent]]></category>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java 编码那些事(三) 实战解决IDEA+Tomcat+Servlet 乱码问题</title>
		<link>http://dengchengchao.com/?p=941</link>
		<pubDate>Fri, 14 Dec 2018 07:39:02 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=941</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Java 编码那些事(三):实战解决IDEA+Tomcat+Servlet 乱码问题</h3>

建议首先阅读：

<a href="http://dengchengchao.com/?p=793">Java 编码那些事(一)</a>

<a href="http://dengchengchao.com/?p=887">Java编码那些事(二)</a>

明白了各种编码问题，现在我们可以着手进行实战。

第一次使用<code>IDEA</code>开发<code>Servlet</code>的时候，大多数都会遇见乱码问题，包括：

<ul>
<li>控制台输出<code>Tomcat</code>日志乱码</p></li>
<li><p>网页显示<code>Servlet</code>返回的中文乱码</p></li>
</ul>

<p>虽然各种Google后，终于解决了，但是可能依然不明白其中的缘由。下面我们来一探究竟

<h3>Tomcat日志</h3>

首先解决Tomcat日志乱码的问题，首先要明白：<strong>Tomcat作为一个独立的进程,IDEA是怎么获取到Tomcat日志的呢</strong>？在IDEA控制台中的Tomcat启动日志中，我们可以找到一个日志记录：

<pre><code class="java"> -Dcatalina.base=C:\xxx\.IntelliJIdea2018.3\system\tomcat\xxx
</code></pre>

复制选项中的路径，在文件夹中打开，进入logs文件夹，就可以发现这个是<code>tomcat</code>的日志文件输出路径，而<strong>IDEA正是读取了这个文件中的内容输出到控制台中</strong>，我们可以使用记事本打开日志文件，然后选择另存为，可以发现文件的默认编码是<strong>ANSI</strong>,也就说在简体中文下是<strong>GBK</strong>编码。
<img src="http://dengchengchao.com/wp-content/uploads/2018/12/coding-1.png" alt="image" />
而读取文本文件内容一般有两种方式，第一种是字符流，第二种是字节流，字节流可以指定字符编码也可以同字符流使用的VM启动参数<code>-Dfile.encoding</code>指定。

明白了上面的问题，我们就能知道为什么乱码了，这是因为<strong>IDEA的默认编码和这个日志文件的编码格式不统一导致的</strong>。

解决方案很简单，<strong>统一两个系统的编码</strong>，对于<code>Tomcat</code>的输出的日志文件，我们可以设置<code>Tomcat</code>启动的VM选项：<code>Edit Configurations</code>-><code>Server</code>-> <code>VM options</code>编辑添加：<code>-Dfile.encoding=UTF-8</code>

设置完Tomcat编码后，删除刚刚路径中的日志文件，重启Tomcat服务，再使用记事本打开刚刚的日志文件，另存为我们可以发现，编码已经变成了UTF-8。

<h3>IDEA</h3>

接下来设置IDEA的编码，IDEA默认编码暂时没有找到查找方式，我们也可以将其指定为<code>UTF-8</code>,找到IDEA的安装路径，在<code>bin</code>目录中可以发现一个名为<code>idea.exe.vmoptions</code>和<code>idea64.exe.vmoptions</code>选项，分别打开，添加<code>-Dfile.encoding=UTF-8</code>后，重启IDEA.

完成上面两步后，再次启动Tomcat服务，你会发现日志已经正常。

<blockquote>
  注：如果依然发现乱码，则可能是IDEA缓存了当前项目的编码设置，你可以在当前项目的.idea文件夹中找到encoding.xml文件，删除所有不是UTF-8的编码设置，重启IDEA即可。
</blockquote>

<h3>网页乱码</h3>

网页乱码其实很好解决，如果发现在Servlet中，返回中文给浏览器的时候浏览器返回的是???

点击F12，抓包网络后，找到<code>Response Body</code> 中的<code>charset</code>选项，可以发现<code>charset=ISO-8859-1</code>

也就说默认的Tomcat使用的编码是<code>ISO-8859-1</code>，这是西欧的语言编码，它是不兼容中文的。如果你在<code>Servlet</code>返回的结果中添加一点法语：<code>Ä ä</code>或者德语什么的，你会发现会正常显示。

<code>charset</code>的意思便是Tomcat是以什么样的方式编码字节，而浏览器便会以这样的编码方式解码字节。

我们可以将<code>charset</code>修改为兼容中文的即可，比如<code>UTf-8</code>,<code>GB2312</code>等,建议使用<code>UTF-8</code>，在Servlet中，设置编码的方式为：

<pre><code class="java">response.setCharacterEncoding("UTF-8");
</code></pre>

也可以如下：

<pre><code class="java"> resp.setContentType("text/html;charset=UTF-8");
</code></pre>

建议第一种方式。

到这里，所有的乱码问题都已经解决。

其实，乱码不可怕，可怕的是经历了这么多次乱码却依然不去了解它。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>941</wp:post_id>
		<wp:post_date><![CDATA[2018-12-14 15:39:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-14 07:39:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java-%e7%bc%96%e7%a0%81%e9%82%a3%e4%ba%9b%e4%ba%8b%e4%b8%89-%e5%ae%9e%e6%88%98%e8%a7%a3%e5%86%b3ideatomcatservlet-%e4%b9%b1%e7%a0%81%e9%97%ae%e9%a2%98__trashed]]></wp:post_name>
		<wp:status><![CDATA[trash]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="code"><![CDATA[技术日志]]></category>
		<category domain="post_tag" nicename="%e7%bc%96%e7%a0%81"><![CDATA[编码]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
			<wp:meta_value><![CDATA[publish]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
			<wp:meta_value><![CDATA[1545026243]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_desired_post_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[java-%e7%bc%96%e7%a0%81%e9%82%a3%e4%ba%9b%e4%ba%8b%e4%b8%89-%e5%ae%9e%e6%88%98%e8%a7%a3%e5%86%b3ideatomcatservlet-%e4%b9%b1%e7%a0%81%e9%97%ae%e9%a2%98]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>简单总结面向对象设计原则之SOLID</title>
		<link>http://dengchengchao.com/?p=950</link>
		<pubDate>Thu, 20 Dec 2018 12:56:54 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=950</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>面向对象设计原则</h3>
面向对象设计原则比较出名的便是<code>SOLID</code>，分别是SRP,OCP,LSP,ISP,DIP

其实设计模式最主要的便是想要在各个情况下使代码始终遵循上面的面向对象设计原则，因此在学习设计模式之前一定要清楚各个设计原则的重点，为什么要有这些设计原则？遵循这些设计原则有什么好处？这样才能在以后编写业务逻辑的时候，通过设计模式来达到遵循这些设计原则的目的。

<hr />

<h3>单一职责原则(SRP)</h3>
单一职责原则（<code>Single responsibility principle</code>）是由Robert Cecil Martin 在《敏捷开发，原则，模式和实践》一书中的一篇名为&lt;面向对象设计原则&gt;所提出来的。----<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">维基百科</a>
<h4>定义</h4>
单一职责原则，说简单一点 ，便是<strong>一个类，一个方法，只应该有一个改变的原因</strong>,如果你能够想到多于一个的动机去修改某个类，那么这个类便具有多于一个的职责。

比如在MVC开发的网站中，页面代码的变化不会引起业务逻辑代码的变化，因此MVC模式是符合单一职责原则的，如果将业务逻辑层和页面代码糅合在一起，那么可能某天需要修改一个按钮的样式的时候，却可能引起业务逻辑的bug。
<h4>为什么需要单一职责</h4>
保持一个类专注于单一功能单能够使得类更加健壮，更加容易维护和扩展。

在大话设计模式中，举了手机和专业相机的例子：手机集多个功能与一体，能听歌，打电话，拍照等，而专业相机却只能拍照，但是专业相机的拍照功能却比手机好的多。这就是单一职责带来的好处，因为专一，所以专业。

个人认为，引入单一职责原则，主要在一下几点：
<ul>
 	<li>遵循单一职责的代码复杂度和耦合度低再说MVC中，因为MVC模式遵循单一职责，因此在视图层需要更换一整套样式的时候，业务逻辑却基本不用动，并且视图和业务逻辑分离开来，业务逻辑层可以由专门写业务逻辑层的人写，视图层可以由专门的视图的人写，互不影响</li>
 	<li>遵循单一职责的代码容易阅读，并且可复用

由于一个类/方法只做一件事，因此这个类很容易被复用，并且也不会给引入这个类的人带来不必要的功能</li>
 	<li>遵循单一职责的代码容易扩展

由于类、方法只做一件事，因此在扩展的时候不会“不小心”修改到其他的代码，不容易引起不必要的代码</li>
</ul>
<h4>单一职责应该注意的地方</h4>
理论很容易，但是实践比较难
<ul>
 	<li>不必分离总是同时变化的职责如果在某个业务逻辑中，应用程序的变化总是会导致这两方便同时变化，那么就不必分离他们，如果分离开来，还有可能代码不必要的复杂度</li>
 	<li>不要预先设计

对比非主要功能，仅仅在真实发生变化的时候，再针对变化设计才具有实际意义。在没有提出真正的需求之前，过渡设计一些不会使用的变化，返回会引起不必要的复杂度。</li>
</ul>

<hr />

<h3>开闭原则(OCP)</h3>
开闭原则(<code>Open-closed principle</code>)是由Bertrand Meyer在《面向对象软件构造》一书中提出 ----<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">维基百科</a>
<h4>定义</h4>
开闭原则认为，一个类的实现只应该因为错误而修改，新的或则改变的特性应该新建不同的类来实现。

说简单一点就是一个类在编写完后，就不应该去修改它，如果需要扩展功能，就应该新建其他的类来完成。
<h4>为什么需要开闭原则</h4>
开闭原则是我认为最重要的一个原则，几乎所有的设计模式都是为了达到开闭原则而设计。

正如平时的笑话所说，自己写的代码，一个月以后照样不认识。同样的道理，一个模块，如果某天突然需要增加一个功能，那还得捋一捋逻辑，看一看这块代码应该怎么写，原本的逻辑是怎么样的等等，要是忽略了一个地方，那么增加功能的同时，很可能就会带来bug。

这个时候，开闭原则的好处就体现了，符合开闭原则的代码，在进行扩展的时候，是不需要修改原本的代码的，这至少保证了在扩展 功能后，不会影响到原本的业务逻辑。
<h4>如何做到开闭原则</h4>
说起来比较简单，但是想做到代码符合开闭原则，还是比较难的

首先应该明白的一点：无论代码设计的多么完善，在面对各种各样的需求的时候，都可能存在一些无法封闭的变化。

因此，在设计某个类的时候，需要首先明确系统功能，找到系统的核心关键点，然后找到其容易发生变化的地方进行设计，然后使它遵循OCP原则。

比如：对于一个计算器来说，计算就是它的核心功能，因此对于计算功能，应该就是其容易变化的地方，比如刚开始只有加减乘除功能，后续可能会增加开方等。所以应该对功能这块代码进行OCP设计。

而对于如何做到OCP，最重要的便是<strong>抽象</strong>

比较经典来说，想要做到OCP,<strong>依赖倒转(DIP)</strong>是手段，<strong>里斯替换（LSP）</strong>是基础,在稍后所说的原则中，这两个原则便是需要做到OCP最重要的原则。
<h4>开闭原则需要注意的地方</h4>
开闭原则虽然比较好，但是想要写出符合开闭原则的代码需要一定的水平，并且如果过渡注重开闭原则，有可能带来的后果便是过渡设计，这样反而可能会增加系统的复杂度，因此最好便是明确需求，预测变化。

<hr />

<h3>里斯替换原则（LSP）</h3>
里斯替换原则是由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为“数据的抽象与层次”的演说中首先提出----<a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">维基百科</a>
<h4>什么是里斯替换原则</h4>
其实其实替换原则在Java中，是应用的最多的原则，在刚开始学习面向对象的时候，就明白一个概念叫<strong>多态</strong>，其实，多态便是里斯替换原则的一种体现。

说简单一点，里斯替换原则便是：派生子类必须能够替换掉他们的基类类型（父类）。

就好像在Java中
<pre><code class="java">public static void test(Object o){
    System.out.println(o.hashCode());
}
</code></pre>
这里，虽然说需要传入的类型是<code>Object</code>类型，但是我们知道如果某个类型继承自<code>Object</code>类型，那它一定包含<code>hashCode()</code>方法，因此，这里我们可以传入任意<code>Object</code>的子类。
<h4>为什么需要里斯替换原则</h4>
其实，只要接触过面向对象的原则的程序员，都使用过里斯替换原则，并且能够说出它的好处：可复用。

正因为子类能够替换基类，这样写出来的方法才能被复用。
<h4>里斯替换原则需要注意的地方</h4>
实现里斯替换原则比较简单，基本的语言的语法都遵循里斯替换原则，但是在编写业务逻辑的时候，有几点需要注意：
<ul>
 	<li>每个子类所实现的方法对外来看，应该差不多。
<pre><code class="java">interface Add{
  int add(int a,int b);
}
public class AddImpl1{
  @Override
  pubic void int add(int a,int b){
     return a+b; 
  }
}

public class AddImpl2{
  @Override
  pubic void int add(int a,int b){
     return a-b; 
  }
}
</code></pre>
可以看到，<code>AddImpl1</code>和<code>AddImpl2</code>虽然都实现了<code>add</code>方法，在编译过程中完全正确，但是在逻辑上来看<code>AddImpl2</code>是不能替换<code>AddImpl1</code>的。</li>
 	<li>里斯替换原则虽然好，但是在实现的时候，只有真正是<code>is-a</code>才能使用继承实现里斯替换，如果是<code>has-a</code>，则应该使用组合，可以参见另外一条设计原则：组合优先于继承原则</li>
</ul>

<hr />

<h3>接口隔离原则（ISP）</h3>
接口隔离原则(<code>interface-segregation principles</code>)是指客户应该不依赖于它不使用的方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为<strong>角色接口</strong>（role interfaces）-----<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">维基百科</a>
<h4>什么是接口隔离原则</h4>
说简单点，接口隔离原则便是 <strong>不应该强迫客户依赖于它们不用的方法。</strong>

也就是说如果一个客户端程序依赖一个比较庞大的类，那么从客户端的角度来说，无疑增加了客户端的使用难度

更重要的是，如果其他客户程序却确实要使用该客户不使用的方法，那么当其他客户要求这个类改变时，就很可能会影响到这个客户程序。
<h4>为什么需要接口隔离原则</h4>
因为接口具有强迫性，实现接口的类，都必须完整的实现接口中的所有方法，因此如果设计的接口中包含过多的接口，那会给所有实现该接口的类带来额外的负担
<h4>如何实现接口隔离原则</h4>
<ul>
 	<li>可以使用委托分离接口，比如适配器模式。</li>
 	<li>也可以是用多重继承分离开接口</li>
</ul>
通常优先使用第二种方法。
<h4>接口隔离原则注意事项</h4>
使用接口隔离原则的时候，需要主要分离接口的粒度，不能太大，也能不太小。并且在分离的时候需要考虑用户是如何使用该接口的。如果某两个方法用户需要同时使用，这个时候就比较麻烦。

<hr />

<h3>依赖倒转原则(DIP）</h3>
<strong>依赖反转原则</strong>（Dependency inversion principle，DIP）由罗伯特·C·马丁提出，是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象-----<a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99">维基百科</a>
<h4>依赖倒转原则是什么</h4>
说简单点，依赖倒转原则主要有两点：

1) 高层模块不依赖于底层模块，两者都应该依赖于抽象

2)抽象不应该依赖于细节，细节应该依赖于抽象

什么意思呢，也就是传统我们的类中所包含的属性有可能是固定的：
<pre><code class="java">public class Car{
    private String tyre="square";
}
</code></pre>
比如我们创造的第一辆车，轮胎是正方形的。于是有了以上的代码，后来发现，圆形的轮胎更加省力，于是修改代码：
<pre><code class="java">public class Car{
    private String tyre="roundness";
}
</code></pre>
这里便就违背了开闭原则，若在后面，又发现了橡胶轮胎比木头轮胎更加省力，还得再修改代码。但是，如果我们的代码遵循依赖倒转原则：
<pre><code class="java">public class Car{
    private Ityre tyre;

    public Car(Ityre tyre){
        this.tyre=tyre;
    }
}
</code></pre>
将所依赖的属性作为一个参数传入，而所需要的属性是以接口形式依赖，这个时候，无论轮胎发展成什么样，<code>Car</code>这个类都不用修改。这便是依赖倒转原则。

熟悉<code>Spring</code>的同学应该都知道，<code>Spring</code>的一大特性之一便是方便实现依赖注入。

依赖倒置原则应用广泛，在面向对象程序框架设计中（是核心原则）、架构系统中、在社会活动构建组织等方面，都发挥重要作用。
<h3>总结</h3>
本文简单总结了面向对象原则中<strong>SOLID</strong>原则，而面向对象原则远远不止这五个，比如还有迪米特法则，合成复用原则等等。这些原则都是前人经过不断的总结得来的，理解这么原则，能够更好的理解设计模式，更能能够体现面向对象的：可扩展，可复用，灵活，易维护的特性的代码。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>950</wp:post_id>
		<wp:post_date><![CDATA[2018-12-20 20:56:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-20 12:56:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ae%80%e5%8d%95%e6%80%bb%e7%bb%93%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99%e4%b9%8bsolid]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式]]></category>
		<category domain="post_tag" nicename="%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99"><![CDATA[面向对象设计原则]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>15</wp:comment_id>
			<wp:comment_author><![CDATA[GarryKaf]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[parkerbilham@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://bit.ly/2rN5CCg</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[185.206.225.28]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-12-21 19:34:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-12-21 11:34:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hi Look what we affinity for against you! a all fittingskill 
 Are you in?  
 
 
http://bit.ly/2rKpNAq]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>设计模式之简单工厂</title>
		<link>http://dengchengchao.com/?p=957</link>
		<pubDate>Fri, 21 Dec 2018 12:54:49 +0000</pubDate>
		<dc:creator><![CDATA[dengchengchao@outlook.com]]></dc:creator>
		<guid isPermaLink="false">http://dengchengchao.com/?p=957</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>简单工厂（Simple Factory）</h3>

先看问题（form 《大话设计模式》）：

<blockquote>
  业务场景，需要实现一个计算器,能够简单的实现加、减、乘、除
</blockquote>

首先，按照正常的代码来写：

<pre><code class="java">//定义工具类：
public class OperationUtils {

    public static double getResult(String operation, double op1, double op2) {
        switch (operation) {
            case "+":
                return op1 + op2;
            case "-":
                return op1 - op2;
            case "x":
                return op1 * op2;
            case "/":
                return op1 / op2;
            default:
                throw new UnsupportedOperationException("不支持的操作符");
        }
    }
}
//使用
public class Main {
    public static void main(String[] args) {
        double op1=7;
        double op2=9;
        double result= OperationUtils.getResult("+",op1,op2);
    }
}
</code></pre>

分析代码：

<ul>
<li>上面的代码完成了基本的<strong>可复用</strong>功能，虽然符合<strong>单一职责</strong>,但是并没有<em>面向对象思想</em></li>
<li>上面的要求是完成一个计算器，也就是主要业务逻辑便是<strong>计算器</strong>，进行需求分析我们可以发现，这个<strong>计算器</strong>功能肯定是会被扩展的，但是在扩展的时候，我们就必须修改原本的代码</li>
<li>原本的<code>核心</code>逻辑被完全裸露出来，这样在修改代码的时候，更加容易引起致命的bug</li>
</ul>

首先，我们明白上面的代码是不符合面向对象原则的，因为计算类作为核心的业务类，我们却直接将每个逻辑都放在了一个类中，这样带来的问题可能就在扩展功能的时候，很可能就不小心修改了原本的代码，导致新的bug，并且随着功能的完善，比如添加日志等，这个类会越来越臃肿：

因此我们可以使用面向对象将各个功能模块封装起来：

<strong>定义操作符接口</strong>

<pre><code class="java"><br />public abstract class Operation {

    double op1;

    double op2;

    public Operation(double op1, double op2) {
        this.op1 = op1;
        this.op2 = op2;
    }

    public abstract double getResult();
}
</code></pre>

<strong>定义具体的子类</strong>

<pre><code class="java">//定义加法操作
public class AddOperation extends Operation {

    @Override
    public double getResult() {
        return op1+op2;
    }

    public AddOperation(double op1,double op2){
        super(op1,op2);
    }
}
//定义减法操作
public class SubOperation extends Operation{

    @Override
    public double getResult() {
        return op1-op2;
    }

    public SubOperation(double op1,double op2){
        super(op1,op2);
    }
}
//乘法
//除法
//...
</code></pre>

<strong>定义操作符工厂类</strong>

<pre><code class="java"><br />public class OperationFactory {

    public static Operation getOperation(String operation, double op1, double op2) {
        switch (operation) {
            case "+":
                return new AddOperation(op1, op2);
            case "-":
                return new SubOperation(op1, op2);
            case "*":
                return new MulOperation(op1, op2);
            case "/":
                return new DivOperation(op1, op2);
            default:
                throw new UnsupportedOperationException("不支持的操作");
        }

    }
}
</code></pre>

<strong>使用方式如下</strong>

<pre><code class="java">public class Main {
    public static void main(String[] args) {
        double op1=7;
        double op2=9;
        Operation operation= OperationFactory.getOperation("+",op1,op2);
        double result = operation.getResult();
    }
}

</code></pre>

示例代码均在：https://github.com/dengchengchao/design-pattern

可以看到，经过使用面向对象封装了以后，各个<strong>类的职责便分离开来</strong>，<code>Factory</code>就负责根据传入的参数产生不同的类，而其他<code>Operation</code>则负责完成相关的工作。

但是这样的缺点便是产生生了许多的小类，编码工作量提升了不少，但是在面对以后的扩展和修改的时候需求的时候，利是大于弊的。

这便是简单工厂。

<h3>定义</h3>

<ul>
<li>简单工厂模式又叫<strong>静态方法模式</strong>，它属于<strong>类创建型模式</strong>。</p></li>
<li><p>它能将<strong>创建对象</strong>和<strong>对象本身的职责</strong>分割开来</p></li>
<li><p>不属于23种设计模式之一</p></li>
</ul>

<h3>简单工厂解决了什么问题？</h3>

<p>前面说过，简单工厂属于<strong>类创建型模式</strong>，而它的功能是将<strong>创建对象</strong>和<strong>对象本身的职责</strong>分开。

当在类的设计过程中，如果类的行为依赖于用户的输入而定，那么这个类可能会同时担任根据输入选择具体行为的职责，那么在扩展/更新这个类的时候，就很可能不小心修改原本正确的代码。并且还可能随着类的扩展，类越来越雍容。

此时简单工厂就能很好的解决这个问题。

<h4>模式结构</h4>

<img src="http://dengchengchao.com/wp-content/uploads/2018/12/simpleFactory.png" alt="image" />

其中：

<ul>
<li><strong>Client</strong>:通过<code>Factory</code>获取相关对象，并使用相关对象</p></li>
<li><p><strong>Product</strong>:作为抽象产品类，将具体的产品类公共代码封装，使其他具体产品继承该类</p></li>
<li><strong>Factory</strong>: 工厂类，负责根据相关的规则产生出相应的对象</li>
<li><strong>ConcreteProduct</strong>：具体产品类，继承于<code>Product</code></li>
</ul>

<h4>模式优缺点</h4>

<ul>
<li><p>简单工厂只是简单的将功能使用<strong>面向对象</strong>封装起来，但是它依然违背了开闭原则，只是使用简单工厂因为将对象的创造和使用分离开来，降低了出错率。</p></li>
<li><p>使用简单工厂会带来许多的小类，导致代码比较多</p></li>
<li>但是简单工厂能够将对象的创建和使用分开，并且封装了功能代码，增加了容错率</li>
</ul>

<blockquote>
  <p>尊重劳动成果，转载注明出处
</blockquote>

参考文章：<br />
《大话设计模式》<br />
《Head First 设计模式》<br />
<a href="http://zhangyuying.cn/2018/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">简单工厂--张玉莹的个人博客</a><br />
<a href="https://www.cnblogs.com/skywang12345/p/3526186.html">设计模式01之 简单工厂模式(创建模式)</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>957</wp:post_id>
		<wp:post_date><![CDATA[2018-12-21 20:54:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-21 12:54:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e4%b9%8b%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_format" nicename="post-format-aside"><![CDATA[日志]]></category>
		<category domain="category" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式]]></category>
		<category domain="post_tag" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%ef%bc%8c%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82%ef%bc%8c%e5%88%9b%e5%bb%ba%e5%9e%8b%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式，简单工厂，创建型模式]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
